{"version":3,"sources":["styles/useStyles.ts","errors/InputError.tsx","parser/inputTypes.ts","layout/layoutUtils.ts","defaults/Defaults.tsx","layout/treeLayout.ts","utils/utils.ts","layout/arcLayout.ts","layout/layoutTypes.ts","graph/Graph.tsx","parser/parseUtils.ts","utils/helperComponents.tsx","App.tsx","index.js"],"names":["drawerWidth","useStyles","makeStyles","theme","root","display","overflow","appBar","transition","transitions","create","easing","sharp","duration","leavingScreen","appBarShift","width","marginLeft","easeOut","enteringScreen","drawer","flexShrink","drawerPaper","drawerHeader","alignItems","padding","spacing","mixins","toolbar","justifyContent","drawerHeaderText","menuButton","marginRight","hide","mainContent","flexGrow","contentShift","layoutButton","searchBar","flex","formControl","margin","formControlLabel","selectEmpty","marginTop","sliders","position","zIndex","top","right","height","layoutError","InputError","InputType","classes","className","Typography","color","variant","getLabel","type","EdgePairs","WeightedEdgePairs","AdjacencyList","AdjacencyMatrix","GraphObject","BinaryTreeObject","BinaryHeap","LeetcodeTree","getTypeConfig","config","inputType","weighted","directed","oneIndexed","convertToEdgeMap","links","edgeMap","link","src","source","trg","target","hasOwnProperty","push","Set","add","Object","keys","Array","from","deriveStartNode","nodes","nodesWithIn","nodesWithOut","currenNodes","currenNodeList","node","id","has","children","candidates","size","arr","sort","getDisconnectedComponents","startNode","idToNodes","rtn","connectedNodeIds","seen","nodeId","collected","dfs","toAdd","c","unshift","isStartNodeInComponent","spacingArray","layoutTree","data","tree","idToTreeNode","isBinary","isBinaryTree","LayoutUtils","idToNode","rightMostX","disconnectedComponents","comp","actualStartNode","length","constructTreeObject","shiftAmount","runBuchheim","moveSubtree","tNode","realx","Default","x","realy","y","depth","isRightChild","distanceToMove","rightContour","getContours","r","Math","max","prevRightContour","child","leftContour","getMinimumShift","i","val","midpoint","left","curr","next","lo","hi","min","smallerSize","res","l","shift","queue","TreeNode","front","frontVal","value","tempNode","parent","this","generatePermutations","permuteHelper","start","temp","LayoutType","arrangeNodesInLine","nodeRtn","arrangeSubGraph","backNodeId","currNodeId","directedEdgeMap","cycleBack","helperArr","bruteForceMinLineCrossings","recurseArr","origin","backNode","currNode","perms","minCrossings","perm","numCrossings","calculateNumCrossings","idToIndex","forward_cnt","back_cnt","childInd","getLayoutLabel","Tree","ForceLayout","Arc","Random","performLayout","layoutType","undirectedEdgeMap","y_value","sortedNodeIds","sortedNodes","nid","x_offset","DEFAULT_Y_PADDING","layoutArc","console","error","Graph","customNodes","selectedLayout","drawerOpen","searchText","horizontalSpacing","verticalSpacing","React","useState","window","innerHeight","innerWidth","dimensions","setDimensions","oldToNewId","setOldToNewId","graphPaneHeight","graphPaneWidth","argNodes","argLinks","myConfig","nodeHighlightBehavior","staticGraphWithDragAndDrop","labelPosition","labelProperty","fontWeight","fontSize","renderLabel","d3","alphaTarget","gravity","linkLength","linkStrength","disableLinkForce","focusZoom","useEffect","debouncedHandleResize","fn","ms","timer","_","clearTimeout","setTimeout","utils","addEventListener","allIds","values","currIdMap","extraNodes","n","label","focusId","toLowerCase","trim","fontColor","linksToAdd","key","backKey","focusedNodeId","undefined","processInput","input","options","reverseEdges","Error","slice","nodeSet","startInd","nextOpenBracket","indexOf","nextCloseBracket","pair","getDirectedPair","parsePairs","srcNode","toString","parseArray","ex","parseAdjacencyList","matrix","j","colVal","parseInt","parseAdjacencyMatrix","jsonObj","parseJson","message","parseGraphJSON","parseBinaryTreeJSON","nodeToLabel","sp","split","map","elem","ind","trimmed","cleanseInput","leftChildInd","rightChildInd","targetId","parseBinaryHeap","parseLeetcodeTree","s","charAt","LabelWithTooltip","tooltipText","inputRef","onClick","current","focus","Tooltip","style","title","placement","Help","red","lightGrey","ColorButton","withStyles","palette","getContrastText","backgroundColor","Button","SelectedButton","DEFAULT_INPUT_TYPE","DEFAULT_LAYOUT_TYPE","App","setDrawerOpen","inputValue","setInputValue","comboValue","setComboValue","setDirected","setOneIndexed","setReverseEdges","setCustomNodes","allNodes","setAllNodes","setStartNode","graphInputError","setGraphInputError","customNodesInputError","setCustomNodesInputError","customNodeSet","setCustomNodeSet","setData","setSelectedLayout","searchInputValue","setSearchInputValue","setSearchText","graphInputRef","useRef","customNodesInputRef","reverseRef","verticalSlider","setVerticalSlider","horizontalSlider","setHorizontalSlider","parsedValue","ParseUtils","reverseChanged","allNodesSet","tempAllNodes","CssBaseline","AppBar","clsx","Toolbar","IconButton","edge","Menu","noWrap","filter","k","currLayoutType","onChange","newValue","onRequestSearch","onCancelSearch","placeholder","Drawer","anchor","open","paper","ChevronLeft","Divider","FormControl","TextField","InputLabelProps","pointerEvents","multiline","rows","rowsMax","event","helperText","InputLabel","Select","labelId","e","a","b","localeCompare","MenuItem","FormControlLabel","control","Checkbox","checked","name","Autocomplete","renderInput","params","gutterBottom","Slider","step","marks","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"sSAEMA,EAAc,IAEPC,EAAYC,aAAW,SAAAC,GAAK,MAAK,CAE5CC,KAAM,CACJC,QAAS,OACTC,SAAU,UAEZC,OAAQ,CACNC,WAAYL,EAAMM,YAAYC,OAAO,CAAC,SAAU,SAAU,CACxDC,OAAQR,EAAMM,YAAYE,OAAOC,MACjCC,SAAUV,EAAMM,YAAYI,SAASC,iBAGzCC,YAAa,CACXC,MAAM,eAAD,OAAiBhB,EAAjB,OACLiB,WAAYjB,EACZQ,WAAYL,EAAMM,YAAYC,OAAO,CAAC,SAAU,SAAU,CACxDC,OAAQR,EAAMM,YAAYE,OAAOO,QACjCL,SAAUV,EAAMM,YAAYI,SAASM,kBAGzCC,OAAQ,CACNJ,MAAOhB,EACPqB,WAAY,GAEdC,YAAa,CACXN,MAAOhB,GAETuB,aAAa,yBACXlB,QAAS,OACTmB,WAAY,SACZC,QAAStB,EAAMuB,QAAQ,EAAG,IAEvBvB,EAAMwB,OAAOC,SALN,IAMVC,eAAgB,aAElBC,iBAAkB,CAChBd,MAAO,QAETe,WAAY,CACVC,YAAa7B,EAAMuB,QAAQ,IAE7BO,KAAM,CACJ5B,QAAS,QAEX6B,YAAa,CACXC,SAAU,EACVV,QAAStB,EAAMuB,QAAQ,GACvBlB,WAAYL,EAAMM,YAAYC,OAAO,SAAU,CAC7CC,OAAQR,EAAMM,YAAYE,OAAOC,MACjCC,SAAUV,EAAMM,YAAYI,SAASC,gBAEvCG,YAAY,KAEdmB,aAAc,CACZ5B,WAAYL,EAAMM,YAAYC,OAAO,SAAU,CAC7CC,OAAQR,EAAMM,YAAYE,OAAOO,QACjCL,SAAUV,EAAMM,YAAYI,SAASM,iBAEvCF,WAAY,GAEdoB,aAAc,CACZpB,WAAY,GACZe,YAAa,GAEfM,UAAW,CACTjC,QAAS,OACTkC,KAAM,EACNV,eAAgB,YAIlBW,YAAa,CACXC,OAAQtC,EAAMuB,QAAQ,GACtBV,MAAM,eAAD,OAAiB,GAAjB,QAEP0B,iBAAkB,CAChBzB,YAAa,GAEf0B,YAAa,CACXC,UAAWzC,EAAMuB,QAAQ,IAG3BmB,QAAS,CACPC,SAAU,WACVC,OAAQ,IACRC,IAAK,GACLC,MAAO,GACPC,OAAQ,KAEVC,YAAa,CACXnB,YAAa,S,OChFFoB,ICdHC,EDcGD,EAXf,WACI,IAAME,EAAUrD,IAChB,OACI,qBAAKsD,UAAWD,EAAQH,YAAxB,SACI,cAACK,EAAA,EAAD,CAAYC,MAAM,YAAYC,QAAQ,KAAtC,SACK,gC,SCkBR,SAASC,EAASC,GACvB,OAAQA,GACN,KAAKP,EAAUQ,UACb,MAAO,YACT,KAAKR,EAAUS,kBACb,MAAO,qBACT,KAAKT,EAAUU,cACb,MAAO,iBACT,KAAKV,EAAUW,gBACb,MAAO,mBACT,KAAKX,EAAUY,YACb,MAAO,eACT,KAAKZ,EAAUa,iBACb,MAAO,qBACX,KAAKb,EAAUc,WACb,MAAO,sBACT,KAAKd,EAAUe,aACb,MAAO,wBACP,QACE,MAAO,eAIN,SAASC,EAAcT,GAC5B,IAAMU,EAAS,CACbC,UAAWX,EACXY,UAAU,EACVC,UAAU,EACVC,YAAY,GAEd,OAAQd,GACN,KAAKP,EAAUS,kBACbQ,EAAOE,UAAW,EAKtB,OAAOF,G,SA/DCjB,O,yBAAAA,I,yCAAAA,I,iCAAAA,I,qCAAAA,I,6BAAAA,I,uCAAAA,I,2BAAAA,I,gCAAAA,M,kBCQL,SAASsB,EAAiBC,EAA+BH,GAC9D,IAD0F,EACpFI,EAAe,GADqE,cAEvED,GAFuE,IAE1F,2BAA0B,CAAC,IAAhBE,EAAe,QAClBC,EAAMD,EAAKE,OACXC,EAAMH,EAAKI,OACbT,GACGI,EAAQM,eAAeJ,KAC1BF,EAAQE,GAAO,IAEjBF,EAAQE,GAAKK,KAAKH,KAEbJ,EAAQM,eAAeJ,KAC1BF,EAAQE,GAAO,IAAIM,KAErBR,EAAQE,GAAKO,IAAIL,GAEZJ,EAAQM,eAAeF,KAC1BJ,EAAQI,GAAO,IAAII,KAErBR,EAAQI,GAAKK,IAAIP,KAnBqE,8BAuB1F,IAAKN,EACH,cAAgBc,OAAOC,KAAKX,GAA5B,eAAsC,CAAjC,IAAIE,EAAG,KACVF,EAAQE,GAAOU,MAAMC,KAAKb,EAAQE,IAGtC,OAAOF,EAOF,SAASc,EAAgBC,EAAYf,GAC1C,IADoE,EAC9DgB,EAAc,IAAIR,IAClBS,EAAe,IAAIT,IACnBU,EAAc,IAAIV,IAClBW,EAAiB,GAJ6C,cAKnDJ,GALmD,IAKpE,2BAAwB,CAAC,IAAhBK,EAAe,QACtBF,EAAYT,IAAIW,EAAKC,IACrBF,EAAeZ,KAAKa,EAAKC,KAPyC,8BAUpE,cAAgBX,OAAOC,KAAKX,GAA5B,eAAsC,CAAjC,IAAIE,EAAG,KACV,GAAIgB,EAAYI,IAAIpB,GAAM,CACxBe,EAAaR,IAAIP,GACjB,IAFwB,EAElBqB,EAAWvB,EAAQE,GAFD,cAGRqB,GAHQ,IAGxB,2BAA0B,CAAC,IAAlBnB,EAAiB,QACxBY,EAAYP,IAAIL,IAJM,gCAU5B,IArBoE,EAqBhEoB,EAAa,IAAIhB,IArB+C,cAsBnDO,GAtBmD,IAsBpE,2BAAwB,CAAC,IAAhBK,EAAe,SACjBJ,EAAYM,IAAIF,EAAKC,KAAOJ,EAAaK,IAAIF,EAAKC,KACrDG,EAAWf,IAAIW,EAAKC,KAxB4C,8BA4BpE,GAAIG,EAAWC,KAAO,EAAG,CACvB,IAAMC,EAAMd,MAAMC,KAAKW,GAEvB,OADAE,EAAIC,OACGD,EAAI,GAIb,GAA0B,IAAtBT,EAAaQ,KAEf,OADAN,EAAeQ,OACRR,EAAe,GAIxB,IAAMO,EAAMd,MAAMC,KAAKI,GAEvB,OADAS,EAAIC,OACGD,EAAI,GAwBN,SAASE,EACdb,EACAhB,EACA8B,GAEA,IADA,EACMC,EAAgD,GADtD,cAEiBf,GAFjB,IAEA,2BAAwB,CAAC,IAAhBK,EAAe,QACtBU,EAAUV,EAAKC,IAAMD,GAHvB,8BAKA,IALA,EAKMW,EAAqC,GAErCC,EAAmB,IAAIxB,IAP7B,cAQiBT,GARjB,IAQA,2BAAwB,CAAC,IAAhBE,EAAe,QACtB+B,EAAiBvB,IAAIR,EAAKE,QAC1B6B,EAAiBvB,IAAIR,EAAKI,SAV5B,8BAeA,IAFA,IAAML,EAAmBF,EAAiBC,GAAO,GAC3CkC,EAAO,IAAIzB,IACjB,MAAmBI,MAAMC,KAAKmB,GAA9B,eAAiD,CAA5C,IAAIE,EAAM,KACb,IAAKD,EAAKX,IAAIY,GAAS,CACrB,IAAMC,EAAY,IAAI3B,IACtB4B,EAAIF,EAAQlC,EAASiC,EAAME,GAG3B,IADA,IAAME,EAAgC,GACtC,MAAczB,MAAMC,KAAKsB,GAAzB,eAAqC,CAAhC,IAAIG,EAAC,KACRD,EAAM9B,KAAKuB,EAAUQ,IAGnBT,GAAaM,EAAUb,IAAIO,GAC7BE,EAAIQ,QAAQF,GAEZN,EAAIxB,KAAK8B,IAKf,OAAON,EAET,SAASK,EAAIF,EAAgBlC,EAAkBiC,EAAmBE,GAChE,IAAIF,EAAKX,IAAIY,GAAb,CACAD,EAAKxB,IAAIyB,GACTC,EAAU1B,IAAIyB,GACd,IAAMX,EAAWvB,EAAQkC,GACzB,GAAKX,EAAL,CALwF,oBAMtEA,GANsE,IAMxF,2BAA4B,CAC1Ba,EAD0B,QACfpC,EAASiC,EAAME,IAP4D,iCAWnF,SAASK,EAAuBX,EAAmBd,GAAgC,IAAD,gBACtEA,GADsE,IACvF,2BAAwB,CACtB,GADsB,QACbM,KAAOQ,EAAW,OAAO,GAFmD,8BAIvF,OAAO,ECpKF,ICQDY,EAAe,CAAC,GAAI,GAAI,GAAI,IAAK,KAchC,SAASC,EAAWC,EAAkBjD,EAAmB7C,GAC9D,IAAMgF,EAA0Dc,EAA1Dd,UAAWd,EAA+C4B,EAA/C5B,MAAOhB,EAAwC4C,EAAxC5C,MAAOH,EAAiC+C,EAAjC/C,SAAUgD,EAAuBD,EAAvBC,KAAMC,EAAiBF,EAAjBE,aAC3CC,EAVN,SAAsBpD,GACpB,OACEA,IAAclB,EAAUa,kBACxBK,IAAclB,EAAUc,YACxBI,IAAclB,EAAUe,aAMXwD,CAAarD,GACvBoD,IACHlD,GAAW,GAGb,IAPgG,EAO1FI,EAAUgD,EAA6BjD,IAASH,GAClDqD,EAAqB,GAErBC,EAAa,EACXC,EAAyBH,EAAsCjC,EAAOhB,EAAO8B,GAXa,cAa/EsB,GAb+E,IAahG,2BAAyC,CAAC,IAAjCC,EAAgC,QAEnCC,EAAiC,KACjCxB,GAAaA,EAAUyB,OAAS,GAC9BN,EAAmCnB,EAAWuB,KAChDC,EAAkBxB,GAGjBwB,IACHA,EAAkBL,EAA4BI,EAAMpD,IAIxD,IAAIzE,EAAOqH,EACPA,IACFK,EAAWJ,GAERtH,IACJA,EAAOgI,EAAoBvD,EAASqD,EAAiBJ,IAGvD,IAAIO,EAAcN,EAAa,EAAIA,EAlDK,GAkD2C,EACnFA,EAAaO,EAAYlI,EApDF,GAoDyBuH,EAAU,GAC1DY,EAAYnI,EAAMiI,IApC+E,kDAwC/EzC,GAxC+E,IAwChG,2BAAwB,CAAC,IAAhBK,EAAe,QAGhBuC,EAAQV,EADC7B,EAAKC,IAEpB,GAAIsC,EAAO,CACT,IAAIC,EAAQC,GAA2BpB,EAAa5F,EAAQiH,GAAKH,EAAMG,EACnEC,EDlEiB,GCkEatB,EAAa5F,EAAQmH,GAAKL,EAAMK,EAClE5C,EAAK0C,EAAIF,EACTxC,EAAK4C,EAAID,IAhDmF,+BAqDlG,SAASN,EAAYlI,EAAgBqB,EAAiBkG,EAAmBmB,GAGvE,GADA1I,EAAKyI,EAAIC,EACoB,IAAzB1I,EAAKgG,SAAS+B,OAGhB,OADA/H,EAAKuI,EAAI,EACFvI,EAAKuI,EAId,GAA6B,IAAzBvI,EAAKgG,SAAS+B,OAAc,CAG9B,GAFAG,EAAYlI,EAAKgG,SAAS,GAAI3E,EAASkG,EAAUmB,EAAQ,GACzD1I,EAAKuI,EAAIvI,EAAKgG,SAAS,GAAGuC,EACtBhB,EACF,GAAIvH,EAAKgG,SAAS,GAAG2C,aAAc,CACjC,GAAI3I,EAAKgG,SAAS,GAAGuC,EAAI,GAAK,CAC5B,IAAMK,EAAiB,GAAM5I,EAAKgG,SAAS,GAAGuC,EAC9CJ,EAAYnI,EAAKgG,SAAS,GAAI4C,GAEhC5I,EAAKuI,EAAIvI,EAAKgG,SAAS,GAAGuC,EAAI,QAG9BvI,EAAKuI,EAAIvI,EAAKgG,SAAS,GAAGuC,EAAI,GAGlC,IAf8B,EAe1BM,EAAeC,EAAY9I,GAAM,GACjC2H,EAAa3H,EAAKuI,EAhBQ,cAiBhBM,GAjBgB,IAiB9B,2BAA4B,CAAC,IAApBE,EAAmB,QAC1BpB,EAAaqB,KAAKC,IAAItB,EAAYoB,IAlBN,8BAoB9B,OAAOpB,EAGT,IAjCsF,EAiClFuB,EAAkC,GAjCgD,cAmCpElJ,EAAKgG,UAnC+D,IAmCtF,2BAAiC,CAAC,IAAzBmD,EAAwB,QAC/BjB,EAAYiB,EAAO9H,EAASkG,EAAUmB,EAAQ,GAC9C,MAAkCI,EAAYK,GAA9C,mBAAKC,EAAL,KAAkBP,EAAlB,KACA,GAAIM,IAAUnJ,EAAKgG,SAAS,GAAI,CAG9BmC,EAAYgB,EAFKE,EAAgBH,EAAkBE,EAAa/H,IADlC,MAIAyH,EAAYK,GAJZ,mBAI7BC,EAJ6B,KAIhBP,EAJgB,KAMhC,IAAK,IAAIS,EAAI,EAAGA,EAAIJ,EAAiBnB,OAAQuB,IAAK,CAChD,IAAMC,EAAML,EAAiBI,GACzBA,GAAKT,EAAad,OACpBc,EAAa7D,KAAKuE,GAElBV,EAAaS,GAAKN,KAAKC,IAAIJ,EAAaS,GAAIC,GAGhDL,EAAmBL,GApDiE,8BAwDtF,IAAMW,GAAYxJ,EAAKgG,SAAS,GAAGuC,EAAIvI,EAAKgG,SAAShG,EAAKgG,SAAS+B,OAAS,GAAGQ,GAAK,EACpFvI,EAAKuI,EAAIiB,EAGT,IA5DsF,EA4DlF7B,EAAa3H,EAAKuI,EA5DgE,cA6DxEW,GA7DwE,IA6DtF,2BAAgC,CAAC,IAAxBH,EAAuB,QAC9BpB,EAAaqB,KAAKC,IAAItB,EAAYoB,IA9DkD,8BAgEtF,OAAOpB,EAGT,SAASmB,EAAY9I,GAMnB,IAJA,IAAMyJ,EAAsB,GACtB5G,EAAuB,GAEzB6G,EAAO,CAAC1J,GACL0J,EAAK3B,OAAS,GAAG,CACtB,IADsB,EAClB4B,EAAwB,GACxBC,EAAK,UACLC,GAAM,UAHY,cAILH,GAJK,IAItB,2BAAuB,CAAC,IAAD,EAAd7D,EAAc,sBACHA,EAAKG,UADF,IACrB,2BAAiC,CAAC,IAAzBmD,EAAwB,QAC/BQ,EAAK3E,KAAKmE,IAFS,8BAIrBS,EAAKZ,KAAKc,IAAIF,EAAI/D,EAAK0C,GACvBsB,EAAKb,KAAKC,IAAIY,EAAIhE,EAAK0C,IATH,8BAWtBkB,EAAKzE,KAAK4E,GACV/G,EAAMmC,KAAK6E,GACXH,EAAOC,EAET,MAAO,CAACF,EAAM5G,GAGhB,SAASwG,EAAgBR,EAA6BO,EAA4B/H,GAChF,GAA4B,IAAxBwH,EAAad,QAAuC,IAAvBqB,EAAYrB,OAAc,OAAO,EAClE,IAAMgC,EAAcf,KAAKc,IAAIjB,EAAad,OAAQqB,EAAYrB,QAC1DiC,EAAM,EACNZ,EAAY,GAAKP,EAAa,GAAK,IACrCmB,EAAM,GAAKZ,EAAY,GAAKP,EAAa,KAE3C,IAAK,IAAIS,EAAI,EAAGA,EAAIS,EAAaT,IAAK,CACpC,IAAMW,EAAIpB,EAAaS,GACjBP,EAAIK,EAAYE,GAClBP,EAAIkB,EAAI5I,IACV2I,EAAMhB,KAAKC,IAAIe,EAAK3I,GAAW0H,EAAIkB,KAGvC,OAAOD,EAGT,SAAS7B,EAAYnI,EAAgBkK,GACnClK,EAAKuI,GAAK2B,EADwC,oBAEhClK,EAAKgG,UAF2B,IAElD,2BAAiC,CAC/BmC,EAD+B,QACZ+B,IAH6B,+BAQpD,SAASlC,EACPvD,EACA6B,EACAoB,GAGA,IAAIyC,EAAyB,GACzBnK,EAAO,IAAIoK,EAAS9D,GACxB6D,EAAMnF,KAAKhF,GACX,IAAI0G,EAAO,IAAIzB,IAIf,IAHAyB,EAAKxB,IAAIoB,GACToB,EAASpB,GAAatG,EAEfmK,EAAMpC,OAAS,GAAG,CACvB,IAAIsC,EAAkBF,EAAMD,QACxBI,EAAWD,EAAME,MAGrB,GAAK9F,EAAQM,eAAeuF,IAA0C,IAA7B7F,EAAQ6F,GAAUvC,OAA3D,CAIA,IATuB,EASnB/B,EAAWvB,EAAQ6F,GATA,cAULtE,GAVK,IAUvB,2BAA4B,CAAC,IAApBmD,EAAmB,QAC1B,IAAIzC,EAAKX,IAAIoD,GAAb,CACAzC,EAAKxB,IAAIiE,GACT,IAAIqB,EAAW,IAAIJ,EAASjB,GAC5BkB,EAAMrE,SAAShB,KAAKwF,GACpBA,EAASC,OAASJ,EAClBF,EAAMnF,KAAKwF,GAEX9C,EAASyB,GAASqB,IAlBG,gCAqBzB,OAAOxK,EAcF,IAAMoK,EACX,WAAYG,GAAsC,IAAvB5B,EAAsB,4EAC/C+B,KAAKH,MAAQA,EACbG,KAAK1E,SAAW,GAChB0E,KAAKD,OAAS,KACdC,KAAKnC,EAAI,EACTmC,KAAKjC,EAAI,EACTiC,KAAK/B,aAAeA,GCjPjB,SAASgC,EAAqBxE,GACjC,IAAIK,EAAkB,GAEtB,OADAoE,EAAczE,EAAK,EAAGK,GACfA,EAcX,SAASoE,EAAczE,EAAe0E,EAAerE,GACnD,GAAIqE,IAAU1E,EAAI4B,OAAS,EAA3B,CAIA6C,EAAczE,EAAK0E,EAAQ,EAAGrE,GAC9B,IAAK,IAAI8C,EAAIuB,EAAQ,EAAGvB,EAAInD,EAAI4B,OAAQuB,IAAK,CAC3C,IAAIwB,EAAO3E,EAAImD,GACfnD,EAAImD,GAAKnD,EAAI0E,GACb1E,EAAI0E,GAASC,EAEbF,EAAczE,EAAK0E,EAAQ,EAAGrE,GAE9BsE,EAAO3E,EAAImD,GACXnD,EAAImD,GAAKnD,EAAI0E,GACb1E,EAAI0E,GAASC,QAbbtE,EAAIxB,KAAJ,YAAamB,IClBjB,ICAY4E,EDEN7D,EAAe,CAAC,GAAI,GAAI,GAAI,GAAI,KAoDtC,SAAS8D,EACPxF,EACAc,GAEA,IADwB,EAClBM,EAA2B,GAC3BoD,EAAqB,GACrBtC,EAAgB,GAHE,cAIPlC,GAJO,IAIxB,2BAAwB,CAAC,IAAhBK,EAAe,QACtB6B,EAAS7B,EAAKC,IAAMD,EAChBS,GAAaA,IAAcT,EAAKC,GAClCkE,EAAIhF,KAAKsB,GAETM,EAAU5B,KAAKa,EAAKC,KATA,8BAYxBc,EAAUR,OACV,cAAmBQ,EAAnB,eAA8B,CAAzB,IAAID,EAAM,KACbqD,EAAIhF,KAAK2B,GAGX,IADA,IAAMsE,EAAU,GAChB,MAAmBjB,EAAnB,eAAwB,CAAnB,IAAIrD,EAAM,KACbsE,EAAQjG,KAAK0C,EAASf,IAExB,OAAOsE,EAKT,SAASC,EACPzG,EACA0G,EACAC,EACAC,GAEA,IAAK5G,EAAQ2G,IAA8C,IAA/B3G,EAAQ2G,GAAYrD,OAC9C,MAAO,CAACqD,GAGV,IALA,EAKIpB,EAAM,CAACoB,GAEPpF,EAAWvB,EAAQ2G,GACnB1E,EAAO,IAAIzB,IARf,cASkBe,GATlB,IASA,2BAA4B,CAAC,IAApBmD,EAAmB,QAE1B,GAAIA,IAAUgC,IAAczE,EAAKX,IAAIoD,GAArC,CAMA,IAAIvC,EAAY,IAAI3B,IAChBqG,EAAY,EAAC,GAGjB,GAFAzE,EAAIpC,EAASiC,EAAME,EAAW0E,EAAWF,EAAYA,EAAYjC,GAE5DmC,EAAU,GAKR,CACL,IADK,EACDC,EAAYC,EACdH,EACAhG,MAAMC,KAAKsB,GACXwE,GAJG,cAOcG,GAPd,IAOL,2BAA8B,CAAC,IAAtB5E,EAAqB,QACxBA,IAAWyE,GAAYpB,EAAIhF,KAAK2B,IARjC,mCALY,CACjB,IADiB,EACb8E,EAAaP,EAAgBzG,EAAS2G,EAAYjC,EAAOkC,GAD5C,cAEEI,GAFF,IAEjB,2BAA+B,CAAC,IAAvB9E,EAAsB,QAC7BqD,EAAIhF,KAAK2B,IAHM,kCArBrB,8BAsCA,OAAOqD,EAKT,SAASnD,EACPpC,EACAiC,EACAE,EACA0E,EACAI,EACAC,EACAC,GAKA,GAFAlF,EAAKxB,IAAI0G,GACThF,EAAU1B,IAAI0G,GACTnH,EAAQmH,IAA0C,IAA7BnH,EAAQmH,GAAU7D,OAA5C,CAMA,IAVA,EAUI/B,EAAWvB,EAAQmH,GAVvB,cAWkB5F,GAXlB,IAWA,2BAA4B,CAAC,IAApBmD,EAAmB,QACtBA,IAAUwC,IACVxC,IAAUuC,EAIVhF,EAAKX,IAAIoD,IACbtC,EAAIpC,EAASiC,EAAME,EAAW0E,EAAWI,EAAQE,EAAUzC,GAJzDmC,EAAU,IAAK,IAdnB,gCAsBF,SAASE,EACPH,EACAzE,EACA8E,GAEA,GAAI9E,EAAUmB,OAAS,EAErB,OADAnB,EAAUR,OACHQ,EAIT,IAPA,EAOIiF,EAAQlB,EAAqB/D,GAC7BoD,EAAM6B,EAAM,GACZC,EAAe,OATnB,cAUiBD,GAVjB,IAUA,2BAAwB,CAAC,IAAhBE,EAAe,QAClBC,EAAeC,EAAsBZ,EAAiBU,EAAML,GAKhE,GAJIM,EAAeF,IACjBA,EAAeE,EACfhC,EAAM+B,GAEa,IAAjBD,EAAoB,OAhB1B,8BAkBA,OAAO9B,EAET,SAASiC,EACPZ,EACAU,EACAL,GAEA,IAAIQ,EAAiB,GACrBA,EAAUR,IAAW,EAGrB,IAFA,IAAIS,EAAc,GACdC,EAAW,GACN9C,EAAI,EAAGA,EAAIyC,EAAKhE,OAAQuB,IAC/B6C,EAAYnH,KAAK,GACjBoH,EAASpH,KAAK,GACdkH,EAAUH,EAAKzC,IAAMA,EAGvB,IAXQ,EAWJU,EAAM,EAENhE,EAAWqF,EAAgBK,GAAUL,EAAgBK,GAAU,GAb3D,cAcU1F,GAdV,IAcR,2BAA4B,CAC1BmG,EAAYD,EADc,WACO,GAf3B,8BAkBR,IAAK,IAAI5C,EAAI,EAAGA,EAAIyC,EAAKhE,OAAQuB,IAE/B,GADAtD,EAAWqF,EAAgBU,EAAKzC,IAChC,CAFoC,oBAGlBtD,GAHkB,IAGpC,2BAA4B,CAAC,IACrBqG,EAAWH,EADS,SAG1B,GAAIG,EAAW/C,EAEb,IAAK,IAAIf,EAAIe,EAAI,EAAGf,EAAI8D,EAAU9D,IAC5B4D,EAAY5D,KAAIyB,GAAOmC,EAAY5D,SAIzC,IAAK,IAAIA,EAAIe,EAAI,EAAGf,EAAI8D,EAAU9D,IAC5B6D,EAAS7D,KAAIyB,GAAOoC,EAAS7D,KAdH,kDAoBlBvC,GApBkB,IAoBpC,2BAA4B,CAAC,IACrBqG,EAAWH,EADS,SAEtBG,EAAW/C,EACb6C,EAAYE,IAAa,EAGzBD,EAAS9C,IAAM,GA1BiB,+BA8BtC,OAAOU,ECpOF,SAASsC,EAAe9I,GAC7B,OAAQA,GACN,KAAKuH,EAAWwB,KACd,MAAO,OACT,KAAKxB,EAAWyB,YACd,MAAO,iBAGT,KAAKzB,EAAW0B,IACd,MAAO,MACT,KAAK1B,EAAW2B,OACd,MAAO,SACT,QACE,MAAO,eAuBN,SAASC,EACdC,EACAxF,EACAjD,EACA7C,GAEA,OAAQsL,GACN,KAAK7B,EAAWwB,KACd,OAAOpF,EAAWC,EAAMjD,EAAW7C,GAGrC,KAAKyJ,EAAW0B,IACd,ODlDC,SAAmBrF,EAAkB9F,GAC1C,IAD6E,EACvEgF,EAA4Bc,EAA5Bd,UAAWd,EAAiB4B,EAAjB5B,MAAOhB,EAAU4C,EAAV5C,MAElBoD,EAAyBH,EAAsCjC,EAAOhB,EAAO8B,GAC7E+E,EAAkB5D,EAA6BjD,GAAO,GACtDqI,EAAoBpF,EAA6BjD,GAAO,GAE1DsI,EAAUxE,IAP+D,cAS5DV,GAT4D,IAS7E,2BAAyC,CAAC,IAAjCC,EAAgC,QACnCC,OAAmC,EACnCxB,GAAaA,EAAUyB,OAAS,GAC9BN,EAAmCnB,EAAWuB,KAChDC,EAAkBxB,GAGjBwB,IACHA,EAAkBkD,EAAmBnD,EAAMC,GAAiB,GAAGhC,IAGjE,IAXuC,EAWnCiH,EAAgB7B,EAClB2B,EACA,wBACA/E,EACAuD,GAEE3D,EAAgB,GAjBmB,cAkBtBlC,GAlBsB,IAkBvC,2BAAwB,CAAC,IAAhBK,EAAe,QACtB6B,EAAS7B,EAAKC,IAAMD,GAnBiB,8BAqBvC,IArBuC,EAqBnCmH,EAAc,GArBqB,cAsBvBD,GAtBuB,IAsBvC,2BAA+B,CAAC,IAAvBE,EAAsB,QAC7BD,EAAYhI,KAAK0C,EAASuF,KAvBW,8BA4BvC,IADA,IAAIC,EAAW5E,GACf,MAAiB0E,EAAjB,eAA8B,CAAzB,IAAInH,EAAI,KACXA,EAAK0C,EAAI2E,EACTrH,EAAK4C,EAAIqE,EACTI,GAAYhG,EAAa5F,EAAQiH,GAEnCuE,GAAWK,KA1CgE,+BCkDlEC,CAAUhG,EAAM9F,GACzB,KAAKyJ,EAAWyB,YAGhB,KAAKzB,EAAW2B,OAEd,OACF,QAEE,YADAW,QAAQC,MAAM,2B,SAhERvC,O,eAAAA,I,6BAAAA,I,aAAAA,I,oBAAAA,M,KCQZ,IAkMewC,EAlMD,SAAC,GAWU,IAVvBpJ,EAUsB,EAVtBA,UACAiD,EASsB,EATtBA,KACA/C,EAQsB,EARtBA,SACAmJ,EAOsB,EAPtBA,YACAlH,EAMsB,EANtBA,UACAmH,EAKsB,EALtBA,eACAC,EAIsB,EAJtBA,WACAC,EAGsB,EAHtBA,WACAC,EAEsB,EAFtBA,kBACAC,EACsB,EADtBA,gBAEM3K,EAAUrD,IAGhB,EAAoCiO,IAAMC,SAAS,CACjDjL,OAAQkL,OAAOC,YACfrN,MAAOoN,OAAOE,aAFhB,mBAAOC,EAAP,KAAmBC,EAAnB,KAKA,EAAoCN,IAAMC,SAAoC,IAA9E,mBAAOM,EAAP,KAAmBC,EAAnB,KAGMC,EAAkBJ,EAAWrL,OAAS,IACtC0L,EAAiBd,EAAaS,EAAWvN,MAAQ,IAAMuN,EAAWvN,MAAQ,GAG1E6N,EAAW,GACXC,EAAW,GAGXC,EAAW,CACfC,uBAAuB,EACvBC,2BAA4BpB,IAAmB1C,EAAWyB,YAC1D5L,MAAO4N,EACP1L,OAAQyL,EACRlK,SAAUA,EACVwB,KAAM,CACJxC,MAAO,aACP6C,KAAM,IACN4I,cAAe,SACfC,cAAe,QACfC,WAAY,OACZC,SAAU,GAEZvK,KAAM,CACJrB,MAAO,OACP6L,YAAajL,EAAcE,GAAWC,SACtCZ,KAAMiK,IAAmB1C,EAAW0B,IAAM,eAAiB,YAE7D0C,GAAI,CACFC,YAAa,IACbC,SAAU,IACVC,WAAY,IACZC,aAAc,GACdC,kBAAkB,GAEpBC,UAAW,GA0Cb,GAtCA3B,IAAM4B,WAAU,WACd,IAAMC,EHjEH,SAAkBC,EAASC,GAChC,IAAIC,EACJ,OAAO,SAACC,GACNC,aAAaF,GACbA,EAAQG,YAAW,SAAAF,GACjBD,EAAQ,KACRF,MACCC,IG0D2BK,EAAe,WAC3C9B,EAAc,CACZtL,OAAQkL,OAAOC,YACfrN,MAAOoN,OAAOE,eAEf,KACHF,OAAOmC,iBAAiB,SAAUR,MAIpC7B,IAAM4B,WAAU,WACd,IADoB,EACdU,EAAS,IAAInL,IAAYE,OAAOkL,OAAOhC,IACvCiC,EAAuC,GAFzB,cAKHlJ,EAAK5B,OALF,IAKpB,2BAA6B,CAAC,IACxBmB,EADuB,QACTb,GACdsK,EAAOrK,IAAIY,GACb2J,EAAU3J,GAAUA,EAAS,KAE7B2J,EAAU3J,GAAUA,GAVJ,8BAepB,cAAmBtB,MAAMC,KAAKkI,GAA9B,eAA4C,CAAvC,IAAI7G,EAAM,KACTyJ,EAAOrK,IAAIY,GACb2J,EAAU3J,GAAUA,EAAS,KAE7B2J,EAAU3J,GAAUA,EAGxB2H,EAAcgC,KAEb,CAAClJ,EAAMoG,EAAaC,EAAgBnH,EAAWsH,EAAmBC,IAG3C,IAAtBzG,EAAK5B,MAAMuC,OACb,OACE,cAAC,EAAD,IAKJ,IAAIwI,EAAU,YN/BT,SACL/K,EACAhB,GAEA,IADwB,EAClBiC,EAAmB,IAAIxB,IACvBuB,EAA8B,GAFZ,cAGPhC,GAHO,IAGxB,2BAAwB,CAAC,IAAhBE,EAAe,QACtB+B,EAAiBvB,IAAIR,EAAKE,QAC1B6B,EAAiBvB,IAAIR,EAAKI,SALJ,kDAOPU,GAPO,IAOxB,2BAAwB,CAAC,IAAhBK,EAAe,QACjBY,EAAiBV,IAAIF,EAAKC,KAC7BU,EAAIxB,KAAKa,IATW,8BAYxB,OAAOW,EMgBciB,CAA0BL,EAAK5B,MAAO4B,EAAK5C,QAChE,GAAIgJ,GAAeA,EAAYtH,KAAO,EAAG,CACvC,IADuC,EACjCQ,EAAO,IAAIzB,IADsB,cAEzBmC,EAAK5B,OAFoB,IAEvC,2BAA0B,CAAC,IAAlBgL,EAAiB,QACxB9J,EAAKxB,IAAIsL,EAAE1K,KAH0B,gCAMvC,cAAmBT,MAAMC,KAAKkI,GAA9B,eAA4C,CAAvC,IAAI7G,EAAM,KACRD,EAAKX,IAAIY,KACZD,EAAKxB,IAAIyB,GACT4J,EAAWvL,KAAK,CAAEc,GAAIa,EAAQ8J,MAAO9J,MAM3C,IA/GsB,EA0IlB+J,EA3BAnI,EAAIiG,ELvImB,IKwIvB/F,ELvIqB,GKuBH,cAiHL8H,GAjHK,IAiHtB,2BAA6B,CAAC,IAArB1K,EAAoB,QAC3BA,EAAK0C,EAAIA,EACT1C,EAAK4C,EAAIA,EACTA,GL1I8B,IKsBV,gCA+HtB,GAPArB,EAAKd,UAAYA,EACjBc,EAAK/C,SAAWA,EAMY,kBAJPsI,EAAcc,EAAgBrG,EAAMjD,EAAW,CAClEoE,EAAGqF,EACHnF,EAAGoF,IAGH,OACE,qBAAK1K,UAAWD,EAAQH,YAAxB,SACE,cAACK,EAAA,EAAD,CAAYC,MAAM,QAAQC,QAAQ,SAUxC,IADA,IAAMoD,EAAO,IAAIzB,IACjB,6BAAqBmC,EAAK5B,OAA1B,YAAoC+K,IAApC,gBAAiD,CAA5C,IAAI1K,GAAI,MACPc,GAASd,GAAKC,GACdY,EAAKX,IAAIY,MAGbD,EAAKxB,IAAIyB,IACLd,GAAK4K,MAAME,gBAAkBhD,EAAWiD,OAAOD,eACjDD,EAAU/J,GACV8H,EAASzJ,KAAT,2BACKa,IADL,IAEEC,GAAIuI,EAAW1H,KAAWA,GAC1BtD,MAAO,MACPwN,UAAW,YAGbpC,EAASzJ,KAAT,2BAAmBa,IAAnB,IAAyBC,GAAIuI,EAAW1H,KAAWA,OAKvD,IAhKsB,GAgKlBmK,GAAazM,EAAW+C,EAAK5C,MNjB5B,SAA6BA,GAClC,IADiE,EAC7DkC,EAAO,IAAIzB,IACXuB,EAAM,GAFuD,cAGhDhC,GAHgD,IAGjE,2BAAwB,CAAC,IAAhBE,EAAe,QAClBqM,EAAMrM,EAAKE,OAAS,WAAaF,EAAKI,OACtCkM,EAAUtM,EAAKI,OAAS,WAAaJ,EAAKE,OAC1C8B,EAAKX,IAAIiL,KAGbtK,EAAKxB,IAAI6L,GACTvK,EAAIxB,KAAKN,KAVsD,gCAYjE,OAAO8B,EMKkCiB,CAAgCL,EAAK5C,OAhKxD,eAkKLsM,IAlKK,IAkKtB,8BAA6B,CAAC,IAArBpM,GAAoB,SAC3BgK,EAAS1J,KAAT,2BACKN,IADL,IAEEE,OAAQyJ,EAAW3J,GAAKE,SAAWF,GAAKE,OACxCE,OAAQuJ,EAAW3J,GAAKI,SAAWJ,GAAKI,WAtKtB,kCA0KtB,OACE,cAAC,QAAD,CACEgB,GAAG,WACHsB,KAAM,CACJ5B,MAAOiJ,EACPjK,MAAOkK,EACPuC,cAAeP,EAAUrC,EAAWqC,QAAWQ,GAEjDhN,OAAQyK,K,kBCvMP,SAASwC,EAAaC,EAAe5N,EAAc6N,GACxD,IAAMnN,EAASD,EAAcT,GAW7B,OAVAU,EAAOkN,MAAQA,EACXC,IACEA,EAAQ/M,aACVJ,EAAOI,YAAa,GAElB+M,EAAQC,eACVpN,EAAOoN,cAAe,IAIlB9N,GACN,KAAKP,EAAUQ,UACf,KAAKR,EAAUS,kBACb,OA+BC,SAAoBQ,GAMzB,IAAMkN,EAAkDlN,EAAlDkN,MAAN,EAAwDlN,EAA3CE,gBAAb,WAAwDF,EAAzBoN,oBAA/B,SAIE,IADAF,EAAQA,EAAMR,QACL7I,OAAS,EAAG,MAAM,IAAIwJ,MAAM,kCACrCH,EAAQA,EAAMI,MAAM,EAAGJ,EAAMrJ,OAAS,GAEtC,IAAMvD,EAAO,GACPiN,EAAU,IAAIxM,IAEhByM,EAAW,EACXC,EAAkBP,EAAMQ,QAAQ,IAAKF,GACzC,MAA2B,IAArBC,GAAwB,CAC5B,IAAME,EAAmBT,EAAMQ,QAAQ,IAAKD,GAC5C,IAAyB,IAAtBE,EAAyB,MAAM,IAAIN,MAAM,iBAE5C,IACE,IAAMO,EAAOC,EACXX,EAAMI,MAAMG,EAAgB,EAAGE,GAC/BJ,EACArN,EACAkN,GAEF9M,EAAMQ,KAAK8M,GACX,MAAOxE,GACP,MAAMA,EAGRoE,EAAWG,EACXF,EAAkBP,EAAMQ,QAAQ,IAAKF,GAGvC,GAAoB,IAAjBlN,EAAMuD,OAAc,MAAM,IAAIwJ,MAAM,kBAEvC,MAAO,CAACE,QAASA,EAASjN,MAAOA,GAvExBwN,CAAW9N,GACpB,KAAKjB,EAAUU,cACb,OAyGG,SAA4BO,GAKjC,IAAMkN,EAAsBlN,EAAtBkN,MAAO9M,EAAeJ,EAAfI,WAIb,IADA8M,EAAQA,EAAMR,QACL7I,OAAS,EAAG,MAAM,IAAIwJ,MAAM,mCACrCH,EAAQA,EAAMI,MAAM,EAAGJ,EAAMrJ,OAAO,GAEpC,IAAMvD,EAAQ,GACRiN,EAAU,IAAIxM,IAEhByM,EAAW,EACXC,EAAkBP,EAAMQ,QAAQ,IAAKF,GACrCO,EAAU3N,EAAa,EAAI,EAC/B,MAA4B,IAArBqN,GAAwB,CAC7B,IAAME,EAAmBT,EAAMQ,QAAQ,IAAKD,GAC5C,IAA0B,IAAtBE,EAAyB,MAAM,IAAIN,MAAM,iBAE7C,IAAM5M,EAAMsN,EAAQC,WACpBT,EAAQvM,IAAIP,GAEZ,IACE,IADE,EACIwB,EAAMgM,GAAWf,EAAMI,MAAMG,EAAkB,EAAGE,IADtD,cAEc1L,GAFd,IAEF,2BAAqB,CAAC,IAAbtB,EAAY,QACnB4M,EAAQvM,IAAIL,GACVF,IAAQE,GAEVL,EAAMQ,KAAK,CAAEJ,OAAQD,EAAKG,OAAQD,KANlC,+BASF,MAAOuN,GACP,MAAMA,EAGRV,EAAWG,EACXF,EAAkBP,EAAMQ,QAAQ,IAAKF,GACrCO,IAEJ,MAAO,CAAER,QAASA,EAASjN,MAAOA,GAnJvB6N,CAAmBnO,GAC5B,KAAKjB,EAAUW,gBACb,OAqKC,SAA8BM,GACnC,IAAMkN,EAAUlN,EAAVkN,MAEN,IADAA,EAAQA,EAAMR,QACJ7I,OAAS,EAAG,MAAM,IAAIwJ,MAAM,mBACtCH,EAAQA,EAAMI,MAAM,EAAGJ,EAAMrJ,OAAS,GAGtC,IAAMuK,EAAyB,GACzB9N,EAAQ,GACRiN,EAAU,IAAIxM,IAEhByM,EAAW,EACXC,EAAkBP,EAAMQ,QAAQ,IAAKF,GACrCO,EAAU,EACd,MAA4B,IAArBN,GAAwB,CAC7B,IAAME,EAAmBT,EAAMQ,QAAQ,IAAKD,GAC5C,IAA0B,IAAtBE,EAAyB,MAAM,IAAIN,MAAM,6BAE7C,IAAM5M,EAAMsN,EAAQC,WACpBT,EAAQvM,IAAIP,GAEZ+M,EAAWG,EACXF,EAAkBP,EAAMQ,QAAQ,IAAKF,GACrCO,IAIF,IADA,IAAMzB,EAAI8B,EAAOvK,OACRuB,EAAI,EAAGA,EAAIgJ,EAAOvK,OAAQuB,IAAK,CACtC,IAAMnD,EAAMmM,EAAOhJ,GACnB,GAAInD,EAAI4B,SAAWyI,EAAG,MAAM,IAAIe,MAAM,iDACtC,IAAK,IAAIgB,EAAI,EAAGA,EAAI/B,EAAG+B,IAAK,CAC1B,IAAMC,EAASrM,EAAIoM,GAED,IADAE,SAASD,IAEzBhO,EAAMQ,KAAK,CAAEJ,OAAQ0E,EAAE4I,WAAYpN,OAAQyN,EAAEL,cAKnD,MAAO,CAAET,QAASA,EAASjN,MAAOA,GA5MvBkO,CAAqBxO,GAC9B,KAAKjB,EAAUY,YACb,OA6MC,SAAwBK,GAC7B,IAEIyO,EAFEvB,EAAUlN,EAAVkN,MACNA,EAAQA,EAAMR,OAEd,IACE+B,EAAUC,IAAUxB,GACpB,MAAO9D,GACP,MAAM,IAAIiE,MAAMjE,EAAMuF,SAExB,IAAKF,EAAQnN,MACX,MAAM,IAAI+L,MAAM,+CAElB,IAZwD,EAYpD/L,EAAQmN,EAAQnN,MAEdiM,EAAU,IAAIxM,IACdT,EAAQ,GAf0C,cAiBvCgB,GAjBuC,IAiBxD,2BAAwB,CAAC,IAAhBK,EAAe,QAEtB,GADA4L,EAAQvM,IAAIW,EAAKC,IACbD,EAAKG,SAAU,CACjB,IADiB,EACbA,EAAWH,EAAKG,SADH,cAECA,GAFD,IAEjB,2BAA4B,CAAC,IAApBmD,EAAmB,QAC1B3E,EAAMQ,KAAK,CAAEJ,OAAQiB,EAAKC,GAAIhB,OAAQqE,KAHvB,iCAnBmC,8BA2BxD,MAAO,CAAE7C,UAAWqM,EAAQrM,UAAWmL,QAASA,EAASjN,MAAOA,GAxOrDsO,CAAe5O,GACxB,KAAKjB,EAAUa,iBACb,OAyOC,SAA6BI,GAClC,IAEIyO,EAFEvB,EAAUlN,EAAVkN,MACNA,EAAQA,EAAMR,OAEd,IACE+B,EAAUC,IAAUxB,GACpB,MAAO9D,GACP,MAAM,IAAIiE,MAAMjE,EAAMuF,SAGxB,IAAKF,EAAQnN,MACX,MAAM,IAAI+L,MAAM,+CAElB,IAb6D,EAazD/L,EAAQmN,EAAQnN,MAEdiM,EAAU,IAAIxM,IACdT,EAAQ,GAERkD,EAAgB,GAlBuC,cAoB5ClC,GApB4C,IAoB7D,2BAAwB,CAAC,IAAhBK,EAAe,QACtB4L,EAAQvM,IAAIW,EAAKC,IACjB,IAAMsC,EAAQ,IAAIgC,EAASvE,EAAKC,IAChC4B,EAAS7B,EAAKC,IAAMsC,EAEhBvC,EAAK4D,MACPjF,EAAMQ,KAAK,CAAEJ,OAAQiB,EAAKC,GAAIhB,OAAQe,EAAK4D,OAEzC5D,EAAKhD,OACP2B,EAAMQ,KAAK,CAAEJ,OAAQiB,EAAKC,GAAIhB,OAAQe,EAAKhD,SA7Bc,kDAkC5C2C,GAlC4C,IAkC7D,2BAAwB,CAAC,IAAhBK,EAAe,QAChBuC,EAAQV,EAAS7B,EAAKC,IAExBD,EAAK4D,MACPrB,EAAMpC,SAAShB,KAAK0C,EAAS7B,EAAK4D,OAEhC5D,EAAKhD,QACPuF,EAAMpC,SAAShB,KAAK0C,EAAS7B,EAAKhD,QAClC6E,EAAS7B,EAAKhD,OAAO8F,cAAe,IA1CqB,8BA8C7D,MAAO,CACLrC,UAAWqM,EAAQ3S,KACnBqH,KAAMK,EAASiL,EAAQ3S,MACvBsH,aAAcI,EACd+J,QAASA,EACTjN,MAAOA,GA5REuO,CAAoB7O,GAC7B,KAAKjB,EAAUc,WACb,OAgSC,SAAyBG,GAC9B,IAAMkN,EAAUlN,EAAVkN,MAEN,IADAA,EAAQA,EAAMR,QACJ7I,OAAS,EACjB,MAAM,IAAIwJ,MAAM,mBAIlB,GAAqB,KADrBH,GADAA,EAAQA,EAAMI,MAAM,EAAGJ,EAAMrJ,OAAS,IACxB6I,QACJ7I,OACR,MAAM,IAAIwJ,MAAM,mBAElB,IAAME,EAAU,IAAIxM,IACd+N,EAAmB,GACnBxO,EAAoB,GAC1B,IAA4B,IAAxB4M,EAAMQ,QAAQ,KAEhB,OADAH,EAAQvM,IAAIkM,GACL,CAAE9K,UAAW8K,EAAOK,QAASA,EAASjN,MAAOA,GAGtD,IAAIyO,EAAK7B,EAAM8B,MAAM,KACrBD,EAAKA,EAAGE,KAAI,SAACC,EAAMC,GACjB,IAAIC,EAAUC,EAAaH,GACvBrC,EAAMsC,EAAM,SAGhB,OAFAL,EAAYjC,GAAOuC,EACnB7B,EAAQvM,IAAI6L,GACLA,KAIT,IAFA,IACI/Q,EADE0H,EAAgB,GAEb4B,EAAI,EAAGA,EAAI2J,EAAGlL,OAAQuB,IAAK,CAClC,IAAM3E,EAAMsO,EAAG3J,GAEf,GADAmI,EAAQvM,IAAIP,IACP+C,EAAS3C,eAAeJ,GAAM,CACjC,IAAMyD,EAAQ,IAAIgC,EAASzF,GAC3B+C,EAAS/C,GAAOyD,EAER,IAANkB,IACFtJ,EAAO2E,GAGT,IAAI6O,EAAmB,EAAJlK,EAAQ,EACvBmK,EAAoB,EAAJnK,EAAQ,EAC5B,GAAIkK,EAAeP,EAAGlL,OAAQ,CAC5B,IAAM2L,EAAWF,EAAe,SAE1BpL,EAAQ,IAAIgC,EAASsJ,GAC3BhM,EAASgM,GAAYtL,EACrBV,EAAS/C,GAAKqB,SAAShB,KAAKoD,GAE5B5D,EAAMQ,KAAK,CAAEJ,OAAQD,EAAKG,OAAQ4O,IAEpC,GAAID,EAAgBR,EAAGlL,OAAQ,CAC7B,IAAM2L,EAAWD,EAAgB,SAE3BrL,EAAQ,IAAIgC,EAASsJ,GAC3BhM,EAASgM,GAAYtL,EACrBV,EAAS/C,GAAKqB,SAAShB,KAAKoD,GAC5BA,EAAMO,cAAe,EAErBnE,EAAMQ,KAAK,CAAEJ,OAAQD,EAAKG,OAAQ4O,KAGtC,MAAO,CACLpN,UAAWtG,EACXqH,KAAMK,EAAS1H,GACfsH,aAAcI,EACd+J,QAASA,EACTuB,YAAaA,EACbxO,MAAOA,GApWEmP,CAAgBzP,GACzB,KAAKjB,EAAUe,aACb,OAyWC,SAA2BE,GAChC,IAAMkN,EAAUlN,EAAVkN,MAEN,IADAA,EAAQA,EAAMR,QACJ7I,OAAS,EACjB,MAAM,IAAIwJ,MAAM,mBAIlB,GAAqB,KADrBH,GADAA,EAAQA,EAAMI,MAAM,EAAGJ,EAAMrJ,OAAS,IACxB6I,QACJ7I,OACR,MAAM,IAAIwJ,MAAM,mBAGlB,IAAME,EAAU,IAAIxM,IACd+N,EAAmB,GACnBxO,EAAoB,GAE1B,IAA4B,IAAxB4M,EAAMQ,QAAQ,KAEhB,OADAH,EAAQvM,IAAIkM,GACL,CAAE9K,UAAW8K,EAAOK,QAASA,EAASjN,MAAOA,GAGtD,IAAMkD,EAAgB,GAClBuL,EAAK7B,EAAM8B,MAAM,KACrBD,EAAKA,EAAGE,KAAI,SAACC,EAAMC,GACjB,IAAIC,EAAUC,EAAaH,GACvBrC,EAAMsC,EAAM,SAChB,GAAgB,SAAZC,EAAoB,CACtB7B,EAAQvM,IAAI6L,GACZ,IAAM3I,EAAQ,IAAIgC,EAAS2G,GAC3BrJ,EAASqJ,GAAO3I,EAChB4K,EAAYjC,GAAOuC,EAErB,OAAOF,EAAKxC,UAGd,IAAIzG,EAAQ,GACZA,EAAMnF,KAAK,WACX,IAAIqO,EAAM,EACV,KAAOlJ,EAAMpC,OAAS,GAAG,CACvB,IAAIpD,EAAMwF,EAAMD,QAChB,GAAImJ,GAAOJ,EAAGlL,OAAQ,MACtB,IAAIlD,EAAMoO,EAAGI,GAWb,GAVY,SAARxO,IAGFA,EAAMwO,EAAM,SAEZ3L,EAAS/C,GAAeqB,SAAShB,KAAK0C,EAAS7C,IAC/CL,EAAMQ,KAAK,CAAEJ,OAAQD,EAAKG,OAAQD,IAClCsF,EAAMnF,KAAKH,MAEbwO,GACWJ,EAAGlL,OAAQ,MAEV,UADZlD,EAAMoO,EAAGI,MAGPxO,EAAMwO,EAAM,SAEZ3L,EAAS/C,GAAeqB,SAAShB,KAAK0C,EAAS7C,IAC/C6C,EAAS7C,GAAK8D,cAAe,EAC7BnE,EAAMQ,KAAK,CAAEJ,OAAQD,EAAKG,OAAQD,IAClCsF,EAAMnF,KAAKH,IAEbwO,IAGF,MAAO,CACL/M,UAAW,UACXe,KAAMK,EAAS,WACfJ,aAAcI,EACd+J,QAASA,EACTuB,YAAaA,EACbxO,MAAOA,GAjbEoP,CAAkB1P,IAO/B,SAASqP,EAAaM,GAOpB,QANAA,EAAIA,EAAEjD,QACA7I,QAAU,MAAA8L,EAAEC,OAAO,IAAc,MAAAD,EAAEC,OAAOD,EAAE9L,OAAS,IAEhD8L,EAAE9L,QAAU,MAAA8L,EAAEC,OAAO,IAAc,MAAAD,EAAEC,OAAOD,EAAE9L,OAAS,MADhE8L,EAAIA,EAAErC,MAAM,EAAGqC,EAAE9L,OAAS,IAIrB8L,EAgDP,SAAS9B,EACP8B,EACApC,EACArN,EACAkN,GAIF,GAAgB,KAFhBuC,EAAIA,EAAEjD,QAED7I,SAAoC,IAApB8L,EAAEjC,QAAQ,KAC7B,MAAM,IAAIL,MAAM,4CAElB,IAAM0B,EAAKY,EAAEX,MAAM,KACbvO,EAAM4O,EAAaN,EAAG,IACtBpO,EAAM0O,EAAaN,EAAG,IAE5B,GAAkB,IAAftO,EAAIoD,QAA+B,IAAflD,EAAIkD,OACzB,MAAM,IAAIwJ,MAAM,4CAElBE,EAAQvM,IAAIP,GACZ8M,EAAQvM,IAAIL,GAEZ,IAAI2B,EAAW,CAAE5B,OAAQD,EAAKG,OAAQD,GAOtC,OANIyM,IACF9K,EAAM,CAAE5B,OAAQC,EAAKC,OAAQH,IAE5BP,GAA0B,IAAd6O,EAAGlL,SAChBvB,EAAIiK,MAAQwC,EAAG,GAAGrC,QAEbpK,EAkDT,SAAS2L,GAAW0B,GAGhB,IAHkC,EAG5BrN,EAAa,GAEbyM,GAJNY,EAAIA,EAAEjD,QAIOsC,MAAM,KALe,cAMjBD,GANiB,IAMlC,2BAAqB,CAAC,IACdnM,EAAQyM,EADK,SAEfzM,EAAMiB,OAAS,GACjBvB,EAAIxB,KAAK8B,IATqB,8BAalC,OAAON,E,oNCnLEuN,GAAmB,SAAC,GAQ1B,IAPHC,EAOE,EAPFA,YACAvD,EAME,EANFA,MACAwD,EAKE,EALFA,SAMA,OACI,sBACIC,QAAS,WACDD,GAAYA,EAASE,SACrBF,EAASE,QAAQC,SAH7B,UAOK3D,EACD,cAAC4D,GAAA,EAAD,CACIC,MAAO,CAAExR,OAAQ,OAAQT,OAAQ,oBACjCkS,MAAOP,EACPQ,UAAU,QAHd,SAKI,cAACC,GAAA,EAAD,UAOVC,GAAM,UACNC,GAAY,UAELC,GAAcC,cAAW,SAAA9U,GAAK,MAAK,CAC5CC,KAAM,CACFqD,MAAOtD,EAAM+U,QAAQC,gBAAgBJ,IACrCK,gBAAiBL,GACjB,UAAW,CACPK,gBATK,eAIUH,CAQvBI,MAESC,GAAiBL,cAAW,SAAA9U,GAAK,MAAK,CAC/CC,KAAM,CACFqD,MAAOtD,EAAM+U,QAAQC,gBAAgBL,IACrCM,gBAAiBN,GACjB,UAAW,CACPM,gBAAiBN,QALCG,CAQ1BI,M,qBCzBEE,GAAqBlS,EAAUU,cAC/ByR,GAAsBrK,EAAWwB,KA6ZxB8I,OA/Yf,WACE,IAAMnS,EAAUrD,IAEhB,EAAoCiO,IAAMC,UAAS,GAAnD,mBAAOL,EAAP,KAAmB4H,EAAnB,KAGA,EAAoCxH,IAAMC,SAnBnB,IAmBvB,mBAAOwH,EAAP,KAAmBC,EAAnB,KACA,EAAoC1H,IAAMC,SAASoH,IAAnD,mBAAOM,EAAP,KAAmBC,EAAnB,KACA,EAAgC5H,IAAMC,UAAS,GAA/C,mBAAO1J,EAAP,KAAiBsR,EAAjB,KACA,EAAoC7H,IAAMC,UAAS,GAAnD,mBAAOzJ,EAAP,KAAmBsR,EAAnB,KACA,EAAwC9H,IAAMC,UAAS,GAAvD,mBAAOuD,EAAP,KAAqBuE,EAArB,KACA,EAAsC/H,IAAMC,SAxBrB,IAwBvB,mBAAOP,EAAP,KAAoBsI,EAApB,KAEA,EAAgChI,IAAMC,SAAwB,IAA9D,mBAAOgI,EAAP,KAAiBC,EAAjB,KACA,EAAkClI,IAAMC,SAAwB,MAAhE,mBAAOzH,EAAP,KAAkB2P,EAAlB,KAGA,EAA8CnI,IAAMC,SAAS,IAA7D,oBAAOmI,GAAP,MAAwBC,GAAxB,MACA,GAA0DrI,IAAMC,SAAS,IAAzE,qBAAOqI,GAAP,MAA8BC,GAA9B,MAGA,GAA0CvI,IAAMC,SAAS,IAAI9I,KAA7D,qBAAOqR,GAAP,MAAsBC,GAAtB,MACA,GAAwBzI,IAAMC,SAAqB,CACjDvI,MAAO,GACPhB,MAAO,KAFT,qBAAO4C,GAAP,MAAaoP,GAAb,MAMA,GAA4C1I,IAAMC,SAASqH,IAA3D,qBAAO3H,GAAP,MAAuBgJ,GAAvB,MACA,GAAgD3I,IAAMC,SAAS,IAA/D,qBAAO2I,GAAP,MAAyBC,GAAzB,MACA,GAAoC7I,IAAMC,SAAS,IAAnD,qBAAOJ,GAAP,MAAmBiJ,GAAnB,MAEMC,GAAgB/I,IAAMgJ,SACtBC,GAAsBjJ,IAAMgJ,SAC5BE,GAAalJ,IAAMgJ,QAAO,GAEhC,GAA4ChJ,IAAMC,SAAiB,GAAnE,qBAAOkJ,GAAP,MAAuBC,GAAvB,MACA,GAAgDpJ,IAAMC,SAAiB,GAAvE,qBAAOoJ,GAAP,MAAyBC,GAAzB,MA6EA,OA1EAtJ,IAAM4B,WAAU,WACd,GAAK6F,EAAL,CAEA,IAAI8B,EACJ,IAME,GAAiC,KALjCA,EAAcC,EAAwB/B,EAAYE,EAAY,CAC5DnR,aACAgN,kBAGcG,QAAQvL,KAEtB,YADAiQ,GAAmB,0CAGrB,MAAO7I,GAEP,YADA6I,GAAmB7I,EAAMuF,SAI3B,IAAI0E,GAAiB,EACjBjG,IAAiB0F,GAAW7C,UAC9BoD,GAAiB,EACjBP,GAAW7C,QAAU7C,GAGvB,IAAM0B,EAAcqE,EAAYrE,YAAcqE,EAAYrE,YAAc,GAExEqE,EAAY7R,MAAQH,MAAMC,KAAK+R,EAAY5F,SAAS0B,KAAI,SAAAxM,GACtD,MAAO,CACLb,GAAIa,EACJ8J,MAAOuC,EAAYjO,eAAe4B,GAAUqM,EAAYrM,GAAoBA,MAG5E0Q,EAAY/Q,UACd2P,EAAaoB,EAAY/Q,WAEpBiR,GACHtB,EAAa,MAIjBE,GAAmB,IACnBK,GAAQa,MACP,CAAC9B,EAAYE,EAAYnR,EAAYgN,IAGxCxD,IAAM4B,WAAU,WACd,GAAKlC,EAAL,CAEA,IAAI6J,EACJ,IACEA,EF2UC,SAAoBjG,GACzB,IAAMK,EAAU,IAAIxM,IAEpB,IADAmM,EAAQA,EAAMR,QACJ7I,OAAS,EACjB,MAAM,IAAIwJ,MAAM,mBAIlB,GAAqB,KADrBH,GADAA,EAAQA,EAAMI,MAAM,EAAGJ,EAAMrJ,OAAS,IACxB6I,QACJ7I,OACR,OAAO0J,EAET,IAA4B,IAAxBL,EAAMQ,QAAQ,KAEhB,OADAH,EAAQvM,IAAIqO,EAAanC,IAClBK,EAET,IAfwC,EAelCwB,EAAK7B,EAAM8B,MAAM,KAfiB,cAgB1BD,GAhB0B,IAgBxC,2BAAkB,CAAC,IAAVY,EAAS,SAChBA,EAAIN,EAAaM,IACX9L,QAAQ0J,EAAQvM,IAAI2O,IAlBY,8BAoBxC,OAAOpC,EE/VW6F,CAAsB9J,GACpC,MAAO4E,GAEP,YADAiE,GAAyBjE,EAAGS,SAG9BwD,GAAyB,IACzBE,GAAiBc,MAChB,CAAC7J,IAEJM,IAAM4B,WAAU,WACd,IADoB,EAChB8H,EAAc,IAAIvS,IADF,cAENmC,GAAK5B,OAFC,IAEpB,2BAA0B,CAAC,IAAlBgL,EAAiB,QACxBgH,EAAYtS,IAAIsL,EAAE1K,KAHA,8BAKpB,cAAmBT,MAAMC,KAAKgR,IAA9B,eAA8C,CAAzC,IAAI3P,EAAM,KACb6Q,EAAYtS,IAAIyB,GAElB,IAAI8Q,EAAepS,MAAMC,KAAKkS,GAC9BC,EAAarR,OAEb4P,EAAYyB,KACX,CAACnB,GAAelP,KAGjB,sBAAKjE,UAAWD,EAAQlD,KAAxB,UACE,cAAC0X,GAAA,EAAD,IACA,cAACC,GAAA,EAAD,CACEjV,SAAS,QACTS,UAAWyU,YAAK1U,EAAQ/C,OAAT,eACZ+C,EAAQvC,YAAc+M,IAH3B,SAME,eAACmK,GAAA,EAAD,WACE,cAACC,GAAA,EAAD,CACEzU,MAAM,UACN,aAAW,cACX6Q,QAAS,WACPoB,GAAc,IAEhByC,KAAK,QACL5U,UAAWyU,YAAK1U,EAAQvB,WAAY+L,GAAcxK,EAAQrB,MAP5D,SASE,cAACmW,GAAA,EAAD,MAGF,cAAC5U,EAAA,EAAD,CAAYE,QAAQ,KAAK2U,QAAM,EAA/B,iCAKC9S,OAAOC,KAAK2F,GACVmN,QAAO,SAAAC,GAAC,MAAoC,kBAAzBpN,EAAWoN,MAC9BhF,KAAI,SAAApC,GACH,IAAIqH,EAAiB3F,SAAS1B,GAC9B,OAAOqH,IAAmB3K,GACxB,cAACyH,GAAD,CAEE/R,UAAWD,EAAQjB,aACnBqB,QAAQ,YACR4Q,QAAS,WACPuC,GAAkB2B,IALtB,SAQG9L,EAAemG,SAAS1B,KAPpBA,GAUP,cAAC6D,GAAD,CAEEzR,UAAWD,EAAQjB,aACnBqB,QAAQ,YACR4Q,QAAS,WACPuC,GAAkB2B,IALtB,SAQG9L,EAAemG,SAAS1B,KAPpBA,MAYb,qBAAK5N,UAAWD,EAAQhB,UAAxB,SACE,cAAC,KAAD,CACEqI,MAAOmM,GACP2B,SAAU,SAAAC,GAAQ,OAAI3B,GAAoB2B,IAC1CC,gBAAiB,kBAAM3B,GAAcF,KACrC8B,eAAgB,kBAAM5B,GAAc,KACpC6B,YAAa,eACbnE,MAAO,CACL1T,MAAO,IACPkC,OAAQ,aAOlB,eAAC4V,GAAA,EAAD,CACEvV,UAAWD,EAAQlC,OACnBsC,QAAQ,aACRqV,OAAO,OACPC,KAAMlL,EACNxK,QAAS,CACP2V,MAAO3V,EAAQhC,aANnB,UASE,sBAAKiC,UAAWD,EAAQ/B,aAAxB,UACE,cAACiC,EAAA,EAAD,CAAYD,UAAWD,EAAQxB,iBAAkB4B,QAAQ,KAAK2U,QAAM,EAApE,yBAGA,cAACH,GAAA,EAAD,CACE5D,QAAS,WACPoB,GAAc,IAFlB,SAKE,cAACwD,GAAA,EAAD,SAGJ,gCACE,cAACC,GAAA,EAAD,IACA,cAACC,GAAA,EAAD,CAAa7V,UAAWD,EAAQd,YAAhC,SACE,cAAC6W,GAAA,EAAD,CACEC,gBAAiB,CAAE5E,MAAO,CAAE6E,cAAe,SAC3C1I,MACE,cAAC,GAAD,CACEA,MAAO,cACPuD,YAAa,8CACbC,SAAU4C,KAGd5C,SAAU4C,GACV4B,YAAY,4BACZW,WAAS,EACTC,KAAM,EACNC,QAAS,GACThW,QAAQ,WACRiH,MAAOgL,EACP8C,SAAU,SAAAkB,GACR/D,EAAc+D,EAAMzU,OAAOyF,QAE7B+C,MAAO4I,GAAgBnO,OAAS,EAChCyR,WAAYtD,OAGhB,eAAC8C,GAAA,EAAD,CAAa7V,UAAWD,EAAQd,YAAhC,UACE,cAACqX,GAAA,EAAD,CAAY3T,GAAG,yBAAf,wBACA,cAAC4T,GAAA,EAAD,CACEC,QAAQ,yBACR7T,GAAG,mBACHyE,MAAOkL,EACPtS,UAAWD,EAAQX,YACnBe,QAAQ,WACR+U,SAAU,SAAAuB,GACRlE,EAAcjD,SAASmH,EAAE9U,OAAOyF,SAPpC,SAUGpF,OAAOC,KAAKnC,GACViV,QAAO,SAAAC,GAAC,MAAmC,kBAAxBlV,EAAUkV,MAC7B/R,MAAK,SAACyT,EAAGC,GAAJ,OAAUvW,EAASkP,SAASoH,IAAIE,cAAcxW,EAASkP,SAASqH,QACrE3G,KAAI,SAAApC,GAAG,OACN,cAACiJ,GAAA,EAAD,CAAoBzP,MAAOwG,EAA3B,SACGxN,EAASkP,SAAS1B,KADNA,WAMtB0E,IAAexS,EAAUU,eACxB,cAACsW,GAAA,EAAD,CACE9W,UAAWD,EAAQZ,iBACnB4X,QACE,cAACC,GAAA,EAAD,CACEC,QAAS9V,EACT+T,SAAU,SAAAuB,GAAC,OAAIhE,GAAetR,IAC9B+V,KAAK,kBACLhX,MAAM,YAGVoN,MAAM,cAGTgF,IAAexS,EAAUQ,WACxB,cAACwW,GAAA,EAAD,CACE9W,UAAWD,EAAQZ,iBACnB4X,QACE,cAACC,GAAA,EAAD,CACEC,QAAS9I,EACT+G,SAAU,SAAAuB,GAAC,OAAI/D,GAAiBvE,IAChC+I,KAAK,eACLhX,MAAM,YAGVoN,MAAM,YAGV,cAACwJ,GAAA,EAAD,CACE9W,UAAWD,EAAQZ,iBACnB4X,QACE,cAACC,GAAA,EAAD,CACEC,QAAS/V,EACTgU,SAAU,SAAAuB,GAAC,OAAIjE,GAAatR,IAC5BgW,KAAK,gBACLhX,MAAM,YAGVoN,MAAM,aAER,cAACuI,GAAA,EAAD,CAAa7V,UAAWD,EAAQd,YAAhC,SACE,cAACkY,GAAA,EAAD,CACEjJ,QAAS0E,EACTxL,MAAOjE,GAAaA,EAAUyB,OAAS,EAAIzB,EAAY,KACvD+R,SAAU,SAACkB,EAA8BjB,GACnCA,GAAUrC,EAAaqC,IAE7BiC,YAAa,SAACC,GAAD,OACX,cAACvB,GAAA,EAAD,2BAAeuB,GAAf,IAAuB/J,MAAM,aAAapO,OAAO,SAASiB,QAAQ,mBAIxE,cAAC0V,GAAA,EAAD,CAAa7V,UAAWD,EAAQd,YAAhC,SACE,cAAC6W,GAAA,EAAD,CACEC,gBAAiB,CAAE5E,MAAO,CAAE6E,cAAe,SAC3C1I,MACE,cAAC,GAAD,CACEA,MAAO,mBACPuD,YACE,yFAEFC,SAAU8C,KAGd9C,SAAU8C,GACV0B,YAAY,8BACZW,WAAS,EACTC,KAAM,EACNC,QAAS,GACThW,QAAQ,WACRiH,MAAOiD,EACP6K,SAAU,SAAAkB,GACRzD,EAAeyD,EAAMzU,OAAOyF,QAE9B+C,MAAO8I,GAAsBrO,OAAS,EACtCyR,WAAYpD,aAKpB,uBACEjT,UAAWyU,YAAK1U,EAAQpB,YAAT,eACZoB,EAAQlB,aAAe0L,IAF5B,UAKE,qBAAKvK,UAAWD,EAAQ/B,eACxB,cAAC,EAAD,CACE2E,GAAG,WACH3B,UAAWsR,EACXpR,SAAUA,EACVmJ,YAAa8I,GACbhQ,UAAWA,EACXc,KAAMA,GACNqG,eAAgBA,GAChBC,WAAYA,EACZC,WAAYA,GACZC,kBAAmBuJ,GACnBtJ,gBAAiBoJ,KAEnB,sBAAK9T,UAAWD,EAAQT,QAAxB,UACGgL,KAAmB1C,EAAWyB,aAAeiB,KAAmB1C,EAAW2B,QAC1E,qCACE,cAACtJ,EAAA,EAAD,CAAY0C,GAAG,oBAAoB2U,cAAY,EAA/C,gCAGA,cAACC,GAAA,EAAD,CACEnQ,MAAO4M,GACPkB,SAAU,SAACkB,EAAOjB,GAChBlB,GAAoBkB,IAEtB,kBAAgB,kBAChBqC,KAAM,EACNC,OAAK,EACL9Q,IAAK,EACLb,IAAK,OAIVwE,KAAmB1C,EAAWyB,aAC7BiB,KAAmB1C,EAAW2B,QAC9Be,KAAmB1C,EAAW0B,KAC5B,qCACE,cAACrJ,EAAA,EAAD,CAAY0C,GAAG,oBAAoB2U,cAAY,EAA/C,8BAGA,cAACC,GAAA,EAAD,CACEnQ,MAAO0M,GACPoB,SAAU,SAACkB,EAAOjB,GAChBpB,GAAkBoB,IAEpB,kBAAgB,kBAChBqC,KAAM,EACNC,OAAK,EACL9Q,IAAK,EACLb,IAAK,iBC9avB4R,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,GAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.6b5656a0.chunk.js","sourcesContent":["import { makeStyles } from \"@material-ui/core/styles\";\n\nconst drawerWidth = 300;\n\nexport const useStyles = makeStyles(theme => ({\n  // layout styles\n  root: {\n    display: \"flex\",\n    overflow: \"hidden\"\n  },\n  appBar: {\n    transition: theme.transitions.create([\"margin\", \"width\"], {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.leavingScreen\n    })\n  },\n  appBarShift: {\n    width: `calc(100% - ${drawerWidth}px)`,\n    marginLeft: drawerWidth,\n    transition: theme.transitions.create([\"margin\", \"width\"], {\n      easing: theme.transitions.easing.easeOut,\n      duration: theme.transitions.duration.enteringScreen\n    })\n  },\n  drawer: {\n    width: drawerWidth,\n    flexShrink: 0\n  },\n  drawerPaper: {\n    width: drawerWidth\n  },\n  drawerHeader: {\n    display: \"flex\",\n    alignItems: \"center\",\n    padding: theme.spacing(0, 1),\n    // necessary for content to be below app bar\n    ...theme.mixins.toolbar,\n    justifyContent: \"flex-end\"\n  },\n  drawerHeaderText: {\n    width: \"100%\"\n  },\n  menuButton: {\n    marginRight: theme.spacing(2)\n  },\n  hide: {\n    display: \"none\"\n  }, \n  mainContent: {\n    flexGrow: 1,\n    padding: theme.spacing(3),\n    transition: theme.transitions.create(\"margin\", {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.leavingScreen\n    }),\n    marginLeft: -drawerWidth\n  },\n  contentShift: {\n    transition: theme.transitions.create(\"margin\", {\n      easing: theme.transitions.easing.easeOut,\n      duration: theme.transitions.duration.enteringScreen\n    }),\n    marginLeft: 0\n  },\n  layoutButton: {\n    marginLeft: 10,\n    marginRight: 0\n  },\n  searchBar: {\n    display: \"flex\",\n    flex: 1,\n    justifyContent: \"flex-end\"\n  },\n  \n  // form styles\n  formControl: {\n    margin: theme.spacing(1),\n    width: `calc(100% - ${30}px)`\n  },\n  formControlLabel: {\n    marginLeft: -4\n  },\n  selectEmpty: {\n    marginTop: theme.spacing(2)\n  },\n\n  sliders: {\n    position: \"absolute\",\n    zIndex: 999,\n    top: 75,\n    right: 30,\n    height: 150\n  },\n  layoutError: {\n    marginRight: 150\n  }\n}));","import { Typography } from \"@material-ui/core\";\nimport { useStyles } from '../styles/useStyles';\n\nfunction InputError() {\n    const classes = useStyles();\n    return (\n        <div className={classes.layoutError}>\n            <Typography color=\"secondary\" variant=\"h6\">\n                {\"<-- Enter a graph input.\"}\n            </Typography>\n        </div>\n    )\n}\n\nexport default InputError;\n","export enum InputType {\n    EdgePairs,\n    WeightedEdgePairs,\n    AdjacencyList,\n    AdjacencyMatrix,\n    GraphObject,\n    BinaryTreeObject,\n    BinaryHeap,\n    LeetcodeTree\n  }\n\n// Declare types\nexport type GraphProps = {\n  inputType: number;\n  data: any;\n  id: string;\n  directed: boolean;\n  customNodes: Set<string>;\n  startNode: string | null;\n  selectedLayout: number;\n  drawerOpen: boolean;\n  searchText: string;\n  horizontalSpacing: number;\n  verticalSpacing: number;\n};\n  \n  export function getLabel(type: number) {\n    switch (type) {\n      case InputType.EdgePairs:\n        return \"Edge List\";\n      case InputType.WeightedEdgePairs:\n        return \"Weighted Edge List\";\n      case InputType.AdjacencyList:\n        return \"Adjacency List\";\n      case InputType.AdjacencyMatrix:\n        return \"Adjacency Matrix\";\n      case InputType.GraphObject:\n        return \"JSON (Graph)\";\n      case InputType.BinaryTreeObject:\n        return \"JSON (Binary Tree)\";\n    case InputType.BinaryHeap:\n      return \"Array (Binary Heap)\";\n    case InputType.LeetcodeTree:\n      return \"Array (Leetcode Tree)\";\n      default:\n        return \"Error Label\";\n    }\n  }\n  \n  export function getTypeConfig(type: InputType): any {\n    const config = {\n      inputType: type,\n      weighted: false,\n      directed: true,\n      oneIndexed: false\n    };\n    switch (type) {\n      case InputType.WeightedEdgePairs:\n        config.weighted = true;\n        break;\n      default:\n        break;\n    }\n    return config;\n  }\n  ","import { MyGraphNodeType, MyGraphLinkType } from \"../App\";\n\nexport type EdgeMap = {\n  [key: string]: Array<string>;\n};\n\n// convert layout into edge map\n// returns map of nodeIds to list of its outgoing nodes\nexport function convertToEdgeMap(links: Array<MyGraphLinkType>, directed: boolean): EdgeMap {\n  const edgeMap: any = {};\n  for (const link of links) {\n    const src = link.source;\n    const trg = link.target;\n    if (directed) {\n      if (!edgeMap.hasOwnProperty(src)) {\n        edgeMap[src] = [];\n      }\n      edgeMap[src].push(trg);\n    } else {\n      if (!edgeMap.hasOwnProperty(src)) {\n        edgeMap[src] = new Set();\n      }\n      edgeMap[src].add(trg);\n\n      if (!edgeMap.hasOwnProperty(trg)) {\n        edgeMap[trg] = new Set();\n      }\n      edgeMap[trg].add(src);\n    }\n\n  }\n  if (!directed) {\n    for (let src of Object.keys(edgeMap)) {\n      edgeMap[src] = Array.from(edgeMap[src]);\n    }\n  }\n  return edgeMap;\n}\n\n// derive start node from nodes and edges (assuming startNode is not defined)\n// 1. find the node that has indegree 0 and outdegree > 0\n// 2. if multiple satisfy #1, return the smallest id\n// 3. else return smallest id out of all nodes with at least 1 outdegree\nexport function deriveStartNode(nodes: any, edgeMap: EdgeMap): string {\n  const nodesWithIn = new Set<string>(); // nodes with indegree\n  const nodesWithOut = new Set<string>(); // nodes with outdegree\n  const currenNodes = new Set<string>();\n  const currenNodeList = [];\n  for (let node of nodes) {\n    currenNodes.add(node.id);\n    currenNodeList.push(node.id);\n  }\n\n  for (let src of Object.keys(edgeMap)) {\n    if (currenNodes.has(src)) {\n      nodesWithOut.add(src);\n      const children = edgeMap[src];\n      for (let trg of children) {\n        nodesWithIn.add(trg);\n      }\n    }\n  }\n\n  // find 1.\n  let candidates = new Set<string>();\n  for (let node of nodes) {\n    if (!nodesWithIn.has(node.id) && nodesWithOut.has(node.id)) {\n      candidates.add(node.id);\n    }\n  }\n\n  if (candidates.size > 0) {\n    const arr = Array.from(candidates);\n    arr.sort();\n    return arr[0];\n  }\n\n  // if 3 doesn't exist, just return smallest nodeId\n  if (nodesWithOut.size === 0) {\n    currenNodeList.sort();\n    return currenNodeList[0];\n  }\n\n  // find 3.\n  const arr = Array.from(nodesWithOut);\n  arr.sort();\n  return arr[0];\n}\n\nexport function getExtraNodes(\n  nodes: Array<MyGraphNodeType>,\n  links: Array<MyGraphLinkType>\n): Array<MyGraphNodeType> {\n  const connectedNodeIds = new Set<string>();\n  const rtn: Array<MyGraphNodeType> = [];\n  for (let link of links) {\n    connectedNodeIds.add(link.source);\n    connectedNodeIds.add(link.target);\n  }\n  for (let node of nodes) {\n    if (!connectedNodeIds.has(node.id)) {\n      rtn.push(node);\n    }\n  }\n  return rtn;\n}\n\n// get all disconeccted components\n// return list of list of nodes\n// Note: the connected component with the start node should always be first in the returned l\nexport function getDisconnectedComponents(\n  nodes: Array<MyGraphNodeType>,\n  links: Array<MyGraphLinkType>,\n  startNode: string | undefined\n) {\n  const idToNodes: { [key: string]: MyGraphNodeType } = {};\n  for (let node of nodes) {\n    idToNodes[node.id] = node;\n  }\n  const rtn: Array<Array<MyGraphNodeType>> = [];\n\n  const connectedNodeIds = new Set<string>();\n  for (let link of links) {\n    connectedNodeIds.add(link.source);\n    connectedNodeIds.add(link.target);\n  }\n\n  const edgeMap: EdgeMap = convertToEdgeMap(links, false);\n  const seen = new Set<string>();\n  for (let nodeId of Array.from(connectedNodeIds)) {\n    if (!seen.has(nodeId)) {\n      const collected = new Set<string>();\n      dfs(nodeId, edgeMap, seen, collected);\n      // collect all the nodes objects in a list\n      const toAdd: Array<MyGraphNodeType> = [];\n      for (let c of Array.from(collected)) {\n        toAdd.push(idToNodes[c]);\n      }\n\n      if (startNode && collected.has(startNode)) {\n        rtn.unshift(toAdd);\n      } else {\n        rtn.push(toAdd);\n      }\n    }\n  }\n\n  return rtn;\n}\nfunction dfs(nodeId: string, edgeMap: EdgeMap, seen: Set<string>, collected: Set<string>) {\n  if (seen.has(nodeId)) return;\n  seen.add(nodeId);\n  collected.add(nodeId);\n  const children = edgeMap[nodeId];\n  if (!children) return;\n  for (let child of children) {\n    dfs(child, edgeMap, seen, collected);\n  }\n}\n\nexport function isStartNodeInComponent(startNode: string, nodes: Array<MyGraphNodeType>) {\n  for (let node of nodes) {\n    if (node.id === startNode) return true;\n  }\n  return false;\n}\n\n// used for undirected graphs: remove links that are backlinks of another edge\nexport function removeRepeatedEdges(links: Array<MyGraphLinkType>) {\n  let seen = new Set<string>();\n  let rtn = [];\n  for (let link of links) {\n    let key = link.source + \"-linkTo-\" + link.target;\n    let backKey = link.target + \"-linkTo-\" + link.source;\n    if (seen.has(backKey)) {\n      continue;\n    }\n    seen.add(key);\n    rtn.push(link);\n  }\n  return rtn;\n}","export const LEFT_PADDING = 100;\nexport const RIGHT_PADDING = 180;\nexport const TOP_PADDING = 50;\nexport const EXTRA_NODE_SPACING = 50;","import { MyDataType } from \"../App\";\nimport * as LayoutUtils from \"./layoutUtils\";\nimport * as Default from \"../defaults/Defaults\";\nimport { InputType } from \"../parser/inputTypes\";\n\nconst DEFAULT_PADDING = 0.4;\nconst DEFAULT_SPACE_BETWEEN_COMPONENTS = 0.8;\n\nconst spacingArray = [50, 75, 90, 125, 160];\n\ntype IdToNode = {\n  [key: string]: TreeNode;\n};\n\nfunction isBinaryTree(inputType: number): boolean {\n  return (\n    inputType === InputType.BinaryTreeObject ||\n    inputType === InputType.BinaryHeap ||\n    inputType === InputType.LeetcodeTree\n  );\n}\n\nexport function layoutTree(data: MyDataType, inputType: number, spacing: { x: number; y: number }){\n  let { startNode, nodes, links, directed, tree, idToTreeNode } = data;\n  let isBinary = isBinaryTree(inputType);\n  if (!isBinary) {\n    directed = false;\n  }\n\n  const edgeMap = LayoutUtils.convertToEdgeMap(links, !!directed);\n  let idToNode: IdToNode = {};\n// run Buchheim algorithm on all disconnected components, then lay them out next to each other\n  let rightMostX = 0;\n  const disconnectedComponents = LayoutUtils.getDisconnectedComponents(nodes, links, startNode);\n\n  for (let comp of disconnectedComponents) {\n    // derive the start node based on if user specified it\n    let actualStartNode: string | null = null;\n    if (startNode && startNode.length > 0) {\n      if (LayoutUtils.isStartNodeInComponent(startNode, comp)) {\n        actualStartNode = startNode;\n      }\n    }\n    if (!actualStartNode) {\n      actualStartNode = LayoutUtils.deriveStartNode(comp, edgeMap);\n    }\n\n  // construct the treeObject\n  let root = tree;\n  if (tree) {\n    idToNode = idToTreeNode as IdToNode;\n  }\n  if (!root) {\n   root = constructTreeObject(edgeMap, actualStartNode, idToNode);\n }\n\n let shiftAmount = rightMostX > 0 ? rightMostX + DEFAULT_SPACE_BETWEEN_COMPONENTS : 0;\n rightMostX = runBuchheim(root, DEFAULT_PADDING, isBinary, 0);\n moveSubtree(root, shiftAmount);\n}\n\n  // assign positions to actual nodes\n  for (let node of nodes) {\n    // normalize node positions based on graph size and padding\n    const nodeId = node.id;\n    const tNode = idToNode[nodeId];\n    if (tNode) {\n      let realx = Default.LEFT_PADDING / 2 + spacingArray[spacing.x] * tNode.x;\n      let realy = Default.TOP_PADDING + spacingArray[spacing.y] * tNode.y;\n      node.x = realx;\n      node.y = realy;\n    }\n  }\n}\n\nfunction runBuchheim(root: TreeNode, padding: number, isBinary: boolean, depth: number) {\n  // if no children, return self at position 0\n  root.y = depth;\n  if (root.children.length === 0) {\n    // this is a leaf node\n    root.x = 0;\n    return root.x;\n  }\n  // if only one child, put it directly above its one child\n  // (unless binary tree, then we must respect left/right child placements)\n  if (root.children.length === 1) {\n    runBuchheim(root.children[0], padding, isBinary, depth + 1);\n    root.x = root.children[0].x;\n    if (isBinary) {\n      if (root.children[0].isRightChild) {\n        if (root.children[0].x < 0.5) {\n          const distanceToMove = 0.5 - root.children[0].x;\n          moveSubtree(root.children[0], distanceToMove);\n        }\n        root.x = root.children[0].x - 0.5;\n      } else {\n        // child is a left child\n        root.x = root.children[0].x + 0.5;\n      }\n    }\n    let rightContour = getContours(root)[1];\n    let rightMostX = root.x;\n    for (let r of rightContour) {\n      rightMostX = Math.max(rightMostX, r);\n    }\n    return rightMostX;\n  }\n\n  let prevRightContour: Array<number> = [];\n\n  for (let child of root.children) {\n    runBuchheim(child, padding, isBinary, depth + 1);\n    let [leftContour, rightContour] = getContours(child);\n    if (child !== root.children[0]) {\n      const minShift = getMinimumShift(prevRightContour, leftContour, padding);\n      // perform the move\n      moveSubtree(child, minShift);\n      [leftContour, rightContour] = getContours(child);\n    }\n    for (let i = 0; i < prevRightContour.length; i++) {\n      const val = prevRightContour[i];\n      if (i >= rightContour.length) {\n        rightContour.push(val);\n      } else {\n        rightContour[i] = Math.max(rightContour[i], val);\n      }\n    }\n    prevRightContour = rightContour;\n  }\n\n  // parent should be in middle of all children\n  const midpoint = (root.children[0].x + root.children[root.children.length - 1].x) / 2;\n  root.x = midpoint;\n\n  // return rightmost point of tree\n  let rightMostX = root.x;\n  for (let r of prevRightContour) {\n    rightMostX = Math.max(rightMostX, r);\n  }\n  return rightMostX;\n}\n\nfunction getContours(root: TreeNode): Array<Array<number>> {\n  // bfs to get the min and max x position of each level\n  const left: Array<number> = [];\n  const right: Array<number> = [];\n\n  let curr = [root];\n  while (curr.length > 0) {\n    let next: Array<TreeNode> = [];\n    let lo = 999999999;\n    let hi = -999999999;\n    for (let node of curr) {\n      for (let child of node.children) {\n        next.push(child);\n      }\n      lo = Math.min(lo, node.x);\n      hi = Math.max(hi, node.x);\n    }\n    left.push(lo);\n    right.push(hi);\n    curr = next;\n  }\n  return [left, right];\n}\n\nfunction getMinimumShift(rightContour: Array<number>, leftContour: Array<number>, padding: number) {\n  if (rightContour.length === 0 || leftContour.length === 0) return 0;\n  const smallerSize = Math.min(rightContour.length, leftContour.length);\n  let res = 0;\n  if (leftContour[0] - rightContour[0] < 1) {\n    res = 1 - (leftContour[0] - rightContour[0]);\n  }\n  for (let i = 1; i < smallerSize; i++) {\n    const l = rightContour[i];\n    const r = leftContour[i];\n    if (r - l < padding) {\n      res = Math.max(res, padding - (r - l));\n    }\n  }\n  return res;\n}\n\nfunction moveSubtree(root: TreeNode, shift: number) {\n  root.x += shift;\n  for (let child of root.children) {\n    moveSubtree(child, shift);\n  }\n}\n\n// recursively constrcut tree object\nfunction constructTreeObject(\n  edgeMap: LayoutUtils.EdgeMap,\n  startNode: string,\n  idToNode: IdToNode\n): TreeNode {\n  // bfs starting from start node\n  let queue: Array<TreeNode> = [];\n  let root = new TreeNode(startNode);\n  queue.push(root);\n  let seen = new Set<string>();\n  seen.add(startNode);\n  idToNode[startNode] = root;\n\n  while (queue.length > 0) {\n    let front: TreeNode = queue.shift() as TreeNode;\n    let frontVal = front.value;\n\n    // create child nodes, add to children, and then add to back of queue\n    if (!edgeMap.hasOwnProperty(frontVal) || edgeMap[frontVal].length === 0) {\n      // this is a leaf node\n      continue;\n    }\n    let children = edgeMap[frontVal];\n    for (let child of children) {\n      if (seen.has(child)) continue;\n      seen.add(child);\n      let tempNode = new TreeNode(child);\n      front.children.push(tempNode);\n      tempNode.parent = front;\n      queue.push(tempNode);\n\n      idToNode[child] = tempNode;\n    }\n  }\n  return root;\n}\n\nexport interface TreeNode {\n  value: string;\n  children: Array<TreeNode>;\n  parent: TreeNode | null;\n\n  x: number;\n  y: number;\n  isRightChild: boolean;\n}\n\n\nexport class TreeNode {\n  constructor(value: string, isRightChild = false) {\n    this.value = value;\n    this.children = [];\n    this.parent = null;\n    this.x = 0;\n    this.y = 0;\n    this.isRightChild = isRightChild;\n  }\n}  ","export function randomInRange(min: number, max: number) {\n    return Math.random() * (max-min)+min;\n}\n\n// generate permutation of integers from 1 to n\nexport function generatePermutations(arr: string[]) {\n    let rtn: string[][] = [];\n    permuteHelper(arr, 0, rtn);\n    return rtn;\n}\n\nexport function debounce(fn: any, ms: number) {\n  let timer: any;\n  return (_: any) => {\n    clearTimeout(timer);\n    timer = setTimeout(_ => {\n      timer = null;\n      fn();\n    }, ms);\n  };\n}\n\nfunction permuteHelper(arr: string[], start: number, rtn: string[][]) {\n  if (start === arr.length - 1) {\n    rtn.push([...arr]);\n    return;\n  }\n  permuteHelper(arr, start + 1, rtn);\n  for (let i = start + 1; i < arr.length; i++) {\n    let temp = arr[i];\n    arr[i] = arr[start];\n    arr[start] = temp;\n  \n    permuteHelper(arr, start + 1, rtn);\n  \n    temp = arr[i];\n    arr[i] = arr[start];\n    arr[start] = temp;\n  }\n}","import * as LayoutUtils from \"./layoutUtils\";\nimport { MyDataType, MyGraphNodeType } from \"../App\";\nimport * as Default from \"../defaults/Defaults\";\nimport { generatePermutations } from \"../utils/utils\";\n\n\nconst DEFAULT_Y_PADDING = 120;\n\nconst spacingArray = [50, 60, 75, 95, 125];\n\nconst DEFAULT_MAX_LEN_TO_BRUTE_FORCE = 5;\n\nexport function layoutArc(data: MyDataType, spacing: { x: number; y: number }) {\n  let { startNode, nodes, links } = data;\n\n  const disconnectedComponents = LayoutUtils.getDisconnectedComponents(nodes, links, startNode);\n  const directedEdgeMap = LayoutUtils.convertToEdgeMap(links, true);\n  const undirectedEdgeMap = LayoutUtils.convertToEdgeMap(links, false);\n\n  let y_value = Default.TOP_PADDING + DEFAULT_Y_PADDING / 2;\n\n  for (let comp of disconnectedComponents) {\n    let actualStartNode: string | undefined;\n    if (startNode && startNode.length > 0) {\n      if (LayoutUtils.isStartNodeInComponent(startNode, comp)) {\n        actualStartNode = startNode;\n      }\n    }\n    if (!actualStartNode) {\n      actualStartNode = arrangeNodesInLine(comp, actualStartNode)[0].id;\n    }\n\n    let sortedNodeIds = arrangeSubGraph(\n      undirectedEdgeMap,\n      \"DUMMYNODE_DO_NOT_COPY\",\n      actualStartNode,\n      directedEdgeMap\n    );\n    let idToNode: any = {};\n    for (let node of nodes) {\n      idToNode[node.id] = node;\n    }\n    let sortedNodes = [];\n    for (let nid of sortedNodeIds) {\n      sortedNodes.push(idToNode[nid]);\n    }\n\n    // assign positions to the sorted notes\n    let x_offset = Default.LEFT_PADDING / 2;\n    for (let node of sortedNodes) {\n      node.x = x_offset;\n      node.y = y_value;\n      x_offset += spacingArray[spacing.x];\n    }\n    y_value += DEFAULT_Y_PADDING * 2;\n  }\n}\n\n// return node list sorted by node ids lexicographical order\n// with startNode (if specified) in front\nfunction arrangeNodesInLine(\n  nodes: Array<MyGraphNodeType>,\n  startNode: string | undefined\n): Array<MyGraphNodeType> {\n  const collected: Array<string> = [];\n  const res: Array<string> = [];\n  const idToNode: any = {};\n  for (let node of nodes) {\n    idToNode[node.id] = node;\n    if (startNode && startNode === node.id) {\n      res.push(startNode);\n    } else {\n      collected.push(node.id);\n    }\n  }\n  collected.sort();\n  for (let nodeId of collected) {\n    res.push(nodeId);\n  }\n  const nodeRtn = [];\n  for (let nodeId of res) {\n    nodeRtn.push(idToNode[nodeId]);\n  }\n  return nodeRtn;\n}\n\n// if not cycle back, layout this node and recurse deeper\n// return an array of nodes in the order we want to place them\nfunction arrangeSubGraph(\n  edgeMap: LayoutUtils.EdgeMap,\n  backNodeId: string,\n  currNodeId: string,\n  directedEdgeMap: LayoutUtils.EdgeMap\n) {\n  if (!edgeMap[currNodeId] || edgeMap[currNodeId].length === 0) {\n    return [currNodeId];\n  }\n\n  let res = [currNodeId];\n  // loop through children\n  let children = edgeMap[currNodeId];\n  let seen = new Set<string>(); // global seen\n  for (let child of children) {\n    // skip back node\n    if (child === backNodeId || seen.has(child)) {\n      continue;\n    }\n\n    // dfs on this subgraph; it not cycleBack, recurse on this child append result to result list\n    // if cycleBack, brute force min line crossing if less than 5 nodes, else call arrangeNodesInLine()\n    let collected = new Set<string>(); // result of dfs\n    let cycleBack = [false];\n    dfs(edgeMap, seen, collected, cycleBack, currNodeId, currNodeId, child);\n\n    if (!cycleBack[0]) {\n      let recurseArr = arrangeSubGraph(edgeMap, currNodeId, child, directedEdgeMap);\n      for (let nodeId of recurseArr) {\n        res.push(nodeId);\n      }\n    } else {\n      let helperArr = bruteForceMinLineCrossings(\n        directedEdgeMap,\n        Array.from(collected),\n        currNodeId\n      );\n\n      for (let nodeId of helperArr) {\n        if (nodeId !== currNodeId) res.push(nodeId);\n      }\n    }\n  }\n  return res;\n}\n\n// determine if this dfs cycles back the prev node;\n// return set of nodes in this dfs\nfunction dfs(\n  edgeMap: LayoutUtils.EdgeMap,\n  seen: Set<string>,\n  collected: Set<string>,\n  cycleBack: Array<boolean>,\n  origin: string,\n  backNode: string,\n  currNode: string\n) {\n  //add to seen and collected\n  seen.add(currNode);\n  collected.add(currNode);\n  if (!edgeMap[currNode] || edgeMap[currNode].length === 0) {\n    return;\n  }\n\n  // loop over children, traverse unseen nodes\n  // update cycle back if seen is origin, unless the origin is the backNode\n  let children = edgeMap[currNode];\n  for (let child of children) {\n    if (child === backNode) continue;\n    if (child === origin) {\n      cycleBack[0] = true;\n      continue;\n    }\n    if (seen.has(child)) continue;\n    dfs(edgeMap, seen, collected, cycleBack, origin, currNode, child);\n  }\n}\n\nfunction bruteForceMinLineCrossings(\n  directedEdgeMap: LayoutUtils.EdgeMap,\n  collected: Array<string>,\n  origin: string\n) {\n  if (collected.length > 1 + DEFAULT_MAX_LEN_TO_BRUTE_FORCE) {\n    collected.sort();\n    return collected;\n  }\n\n  // generate permutations\n  let perms = generatePermutations(collected);\n  let res = perms[0];\n  let minCrossings = 999999;\n  for (let perm of perms) {\n    let numCrossings = calculateNumCrossings(directedEdgeMap, perm, origin);\n    if (numCrossings < minCrossings) {\n      minCrossings = numCrossings;\n      res = perm;\n    }\n    if (minCrossings === 0) break;\n  }\n  return res;\n}\nfunction calculateNumCrossings(\n  directedEdgeMap: LayoutUtils.EdgeMap,\n  perm: Array<string>,\n  origin: string\n): number {\n  let idToIndex: any = {};\n  idToIndex[origin] = -1;\n  let forward_cnt = []; // number of endpoints at each index\n  let back_cnt = [];\n  for (let i = 0; i < perm.length; i++) {\n    forward_cnt.push(0);\n    back_cnt.push(0);\n    idToIndex[perm[i]] = i;\n  }\n\n  let res = 0;\n  // start with origin\n  let children = directedEdgeMap[origin] ? directedEdgeMap[origin] : [];\n  for (let child of children) {\n    forward_cnt[idToIndex[child]] += 1;\n  }\n  // iterate through perm\n  for (let i = 0; i < perm.length; i++) {\n    children = directedEdgeMap[perm[i]];\n    if (!children) continue;\n    for (let child of children) {\n      const childInd = idToIndex[child];\n\n      if (childInd > i) {\n        // if there are any that end between i and childInd, increment crossings\n        for (let x = i + 1; x < childInd; x++) {\n          if (forward_cnt[x]) res += forward_cnt[x];\n        }\n      } else {\n        // child is behind;\n        for (let x = i - 1; x > childInd; x--) {\n          if (back_cnt[x]) res += back_cnt[x];\n        }\n      }\n    }\n\n    // update forward and back count\n    for (let child of children) {\n      const childInd = idToIndex[child];\n      if (childInd > i) {\n        forward_cnt[childInd] += 1;\n      } else {\n        // child is behind\n        back_cnt[i] += 1;\n      }\n    }\n  }\n  return res;\n}","import { InputType } from \"../parser/inputTypes\";\nimport { layoutTree } from \"./treeLayout\";\nimport { layoutArc } from \"./arcLayout\";\n// import { layoutTopoSort } from \"./topologicalSort\";\nimport { MyDataType } from \"../App\";\n\nexport enum LayoutType {\n  Tree,\n  ForceLayout,\n  // TopologicalSort,\n  Arc,\n  Random\n}\n\nexport function getLayoutLabel(type: number) {\n  switch (type) {\n    case LayoutType.Tree:\n      return \"Tree\";\n    case LayoutType.ForceLayout:\n      return \"Force-Directed\";\n    // case LayoutType.TopologicalSort:\n    //   return \"Topological Sort\";\n    case LayoutType.Arc:\n      return \"Arc\";\n    case LayoutType.Random:\n      return \"Random\";\n    default:\n      return \"Error Label\";\n  }\n}\n\nexport function getDefaultLayout({ inputType, data, directed, customNodes, startNode }: any) {\n  switch (inputType) {\n    case InputType.EdgePairs:\n    case InputType.WeightedEdgePairs:\n    case InputType.AdjacencyList:\n    case InputType.AdjacencyMatrix:\n      return LayoutType.Arc;\n    case InputType.GraphObject:\n      return LayoutType.ForceLayout;\n    case InputType.BinaryTreeObject:\n    case InputType.BinaryHeap:\n    case InputType.LeetcodeTree:\n      return LayoutType.Tree;\n    default:\n      return LayoutType.Tree;\n      // return LayoutType.TopologicalSort;\n  }\n}\n\nexport function performLayout(\n  layoutType: number,\n  data: MyDataType,\n  inputType: number,\n  spacing: { x: number; y: number }\n) {\n  switch (layoutType) {\n    case LayoutType.Tree:\n      return layoutTree(data, inputType, spacing);\n    // case LayoutType.TopologicalSort:\n      // return layoutTopoSort(data, spacing);\n    case LayoutType.Arc:\n      return layoutArc(data, spacing);\n    case LayoutType.ForceLayout:\n      // Handled within Graph.tsx\n      return;\n    case LayoutType.Random:\n      // Handled within Graph.tsx\n      return;\n    default:\n      console.error(\"unhandled layout type\");\n      return;\n  }\n}","import React from \"react\";\nimport InputError from \"../errors/InputError\";\nimport { Graph as D3Graph } from \"react-d3-graph\";\nimport { getTypeConfig } from \"../parser/inputTypes\";\nimport { performLayout, LayoutType } from \"../layout/layoutTypes\";\nimport { Typography } from \"@material-ui/core\";\nimport { useStyles } from \"../styles/useStyles\";\nimport * as Default from \"../defaults/Defaults\";\nimport * as utils from \"../utils/utils\";\nimport * as types from \"../parser/inputTypes\";\nimport * as LayoutUtils from \"../layout/layoutUtils\";\n\n\n\nconst Graph = ({\n  inputType,\n  data,\n  directed,\n  customNodes,\n  startNode,\n  selectedLayout,\n  drawerOpen,\n  searchText,\n  horizontalSpacing,\n  verticalSpacing\n}: types.GraphProps) => {\n  const classes = useStyles();\n\n  // Getting dimensions\n  const [dimensions, setDimensions] = React.useState({\n    height: window.innerHeight,\n    width: window.innerWidth\n  });\n\n  const [oldToNewId, setOldToNewId] = React.useState<{ [key: string]: string }>({});\n\n  // Getting Dimensions\n  const graphPaneHeight = dimensions.height - 120;\n  const graphPaneWidth = drawerOpen ? dimensions.width - 350 : dimensions.width - 50;\n\n  // Store data arrays\n  const argNodes = [];\n  const argLinks = [];\n\n  // Config\n  const myConfig = {\n    nodeHighlightBehavior: true,\n    staticGraphWithDragAndDrop: selectedLayout !== LayoutType.ForceLayout,\n    width: graphPaneWidth,\n    height: graphPaneHeight,\n    directed: directed,\n    node: {\n      color: \"lightgreen\",\n      size: 420,\n      labelPosition: \"center\",\n      labelProperty: \"label\" as any,\n      fontWeight: \"bold\",\n      fontSize: 9\n    },\n    link: {\n      color: \"blue\",\n      renderLabel: getTypeConfig(inputType).weighted,\n      type: selectedLayout === LayoutType.Arc ? \"CURVE_SMOOTH\" : \"STRAIGHT\"\n    },\n    d3: {\n      alphaTarget: 0.05,\n      gravity: -180,\n      linkLength: 120,\n      linkStrength: 0.5,\n      disableLinkForce: false\n    },\n    focusZoom: 1\n  };\n\n\n  React.useEffect(() => {\n    const debouncedHandleResize = utils.debounce(function handleResize() {\n      setDimensions({\n        height: window.innerHeight,\n        width: window.innerWidth\n      });\n    }, 100);\n    window.addEventListener(\"resize\", debouncedHandleResize);\n  });\n\n  // every time node set changes, we need to check to see if there are any conflicts in node ids\n  React.useEffect(() => {\n    const allIds = new Set<string>(Object.values(oldToNewId));\n    const currIdMap: { [key: string]: string } = {};\n\n    // Traversing Graph Input\n    for (let node of data.nodes) {\n      let nodeId = node.id;\n      if (allIds.has(nodeId)) {\n        currIdMap[nodeId] = nodeId + \"-1\"; // add a -1 if there is a conflict\n      } else {\n        currIdMap[nodeId] = nodeId;\n      }\n    }\n\n    // Traversing customNodes Input\n    for (let nodeId of Array.from(customNodes)) {\n      if (allIds.has(nodeId)) {\n        currIdMap[nodeId] = nodeId + \"-1\"; // add a -1 if there is a conflict\n      } else {\n        currIdMap[nodeId] = nodeId;\n      }\n    }\n    setOldToNewId(currIdMap);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [data, customNodes, selectedLayout, startNode, horizontalSpacing, verticalSpacing]);\n\n  // Graph Input is empty \n  if (data.nodes.length === 0) {\n    return (\n      <InputError />\n    );\n  }\n\n  // add nodes from customNodes that don't already exist\n  let extraNodes = [...LayoutUtils.getExtraNodes(data.nodes, data.links)];\n  if (customNodes && customNodes.size > 0) {\n    const seen = new Set();\n    for (let n of data.nodes) {\n      seen.add(n.id);\n    }\n    // add if not in seen\n    for (let nodeId of Array.from(customNodes)) {\n      if (!seen.has(nodeId)) {\n        seen.add(nodeId);\n        extraNodes.push({ id: nodeId, label: nodeId });\n      }\n    }\n  }\n\n  // calculate positions for extra nodes\n  let x = graphPaneWidth - Default.RIGHT_PADDING;\n  let y = Default.TOP_PADDING;\n  for (let node of extraNodes) {\n    node.x = x;\n    node.y = y;\n    y += Default.EXTRA_NODE_SPACING;\n  }\n\n  // run layout on all connectd components\n  data.startNode = startNode;\n  data.directed = directed;\n\n  const layoutResult = performLayout(selectedLayout, data, inputType, {\n    x: horizontalSpacing,\n    y: verticalSpacing\n  });\n  if (typeof layoutResult === \"string\") {\n    return (\n      <div className={classes.layoutError}>\n        <Typography color=\"error\" variant=\"h6\">\n          {/* {layoutResult} */}\n        </Typography>\n      </div>\n    );\n  }\n\n\n  let focusId: string | undefined;\n  const seen = new Set<string>();\n  for (let node of [...data.nodes, ...extraNodes]) {\n    let nodeId = node.id;\n    if (seen.has(nodeId)) {\n      continue;\n    }\n    seen.add(nodeId);\n    if (node.label.toLowerCase() === searchText.trim().toLowerCase()) {\n      focusId = nodeId;\n      argNodes.push({\n        ...node,\n        id: oldToNewId[nodeId] || nodeId,\n        color: \"red\",\n        fontColor: \"white\"\n      });\n    } else {\n      argNodes.push({ ...node, id: oldToNewId[nodeId] || nodeId });\n    }\n  }\n\n  // if graph is directed, then remove RepeatedEdges\n  let linksToAdd = directed ? data.links : LayoutUtils.removeRepeatedEdges(data.links);\n\n  for (let link of linksToAdd) {\n    argLinks.push({\n      ...link,\n      source: oldToNewId[link.source] || link.source,\n      target: oldToNewId[link.target] || link.target\n    });\n  }\n\n  return (\n    <D3Graph\n      id=\"graph-id\" // id is mandatory, if no id is defined rd3g will throw an error\n      data={{\n        nodes: argNodes,\n        links: argLinks,\n        focusedNodeId: focusId ? oldToNewId[focusId] : undefined\n      }}\n      config={myConfig}\n    />\n  );\n};\n\nexport default Graph;","import { InputType, getTypeConfig } from \"./inputTypes\";\nimport parseJson from \"parse-json\";\nimport { TreeNode } from \"../layout/treeLayout\";\n\nexport function processInput(input: string, type: number, options?: any): any {\n  const config = getTypeConfig(type);\n  config.input = input;\n  if (options) {\n    if (options.oneIndexed) {\n      config.oneIndexed = true;\n    }\n    if (options.reverseEdges) {\n      config.reverseEdges = true;\n    }\n  }\n\n  switch (type) {\n    case InputType.EdgePairs:\n    case InputType.WeightedEdgePairs:\n      return parsePairs(config);\n    case InputType.AdjacencyList:\n      return parseAdjacencyList(config);\n    case InputType.AdjacencyMatrix:\n      return parseAdjacencyMatrix(config);\n    case InputType.GraphObject:\n      return parseGraphJSON(config);\n    case InputType.BinaryTreeObject:\n      return parseBinaryTreeJSON(config);\n    case InputType.BinaryHeap:\n      return parseBinaryHeap(config);\n    case InputType.LeetcodeTree:\n      return parseLeetcodeTree(config);\n    default:\n      break;\n  }\n}\n\n// trim whitespace and remove quotes\nfunction cleanseInput(s: string) {\n  s = s.trim();\n  if (s.length && s.charAt(0) === `\"` && s.charAt(s.length - 1) === `\"`) {\n    s = s.slice(1, s.length - 1);\n  } else if (s.length && s.charAt(0) === `'` && s.charAt(s.length - 1) === `'`) {\n    s = s.slice(1, s.length - 1);\n  }\n  return s;\n}\n\n// directed pairs\n// [[2,1],[3,1],[1,4]]\nexport function parsePairs(config: {\n  input: string;\n  directed?: boolean;\n  weighted?: boolean;\n  reverseEdges?: boolean;\n}): any {\n  let { input, weighted = false, reverseEdges = false } = config;\n    // trim whitespace\n    // TODO: Error handling\n    input = input.trim();\n    if(input.length < 2) throw new Error(\"Please enter a non-empty input\");\n    input = input.slice(1, input.length - 1);\n\n    const links= [];\n    const nodeSet = new Set<string>();\n\n    let startInd = 0;\n    let nextOpenBracket = input.indexOf(\"[\", startInd);\n    while(nextOpenBracket !== -1) {\n      const nextCloseBracket = input.indexOf(\"]\", nextOpenBracket);\n      if(nextCloseBracket === -1) throw new Error(\"Missing a ']'\");\n\n      try {\n        const pair = getDirectedPair(\n          input.slice(nextOpenBracket+1, nextCloseBracket),\n          nodeSet,\n          weighted,\n          reverseEdges\n        );\n        links.push(pair);\n      } catch (error) {\n        throw error;\n      }\n\n      startInd = nextCloseBracket;\n      nextOpenBracket = input.indexOf(\"[\", startInd);\n    }\n\n    if(links.length === 0) throw new Error(\"No pairs found\");\n\n    return {nodeSet: nodeSet, links: links};\n  }\n\n  function getDirectedPair(\n    s: string,\n    nodeSet: Set<string>,\n    weighted: boolean,\n    reverseEdges: boolean\n  ) {\n  s = s.trim();\n\n  if(s.length === 0 || s.indexOf(\",\") === -1) \n    throw new Error(\"An edge pair has less than two arguments\");\n\n  const sp = s.split(\",\");\n  const src = cleanseInput(sp[0]);\n  const trg = cleanseInput(sp[1]);\n\n  if(src.length === 0 || trg.length === 0) \n    throw new Error(\"An edge pair has less than two arguments\");\n\n  nodeSet.add(src);\n  nodeSet.add(trg);\n\n  let rtn: any = { source: src, target: trg };\n  if (reverseEdges) {\n    rtn = { source: trg, target: src };\n  }\n  if(weighted && sp.length === 3) {\n    rtn.label = sp[2].trim();\n  }\n  return rtn;\n}\n  \n  // adjacency list\n  // array where arr[i] is an array of adjacent nodes\n  export function parseAdjacencyList(config: {\n    input: string;\n    directed?: boolean;\n    oneIndexed?: boolean;\n  }): any {\n    let { input, oneIndexed } = config;\n  \n    // trim whitespace\n    input = input.trim();\n    if(input.length < 2) throw new Error(\"Please enter a non-empty input.\");\n    input = input.slice(1, input.length-1);\n    \n    const links = [];\n    const nodeSet = new Set<string>();\n\n    let startInd = 0;\n    let nextOpenBracket = input.indexOf(\"[\", startInd);\n    let srcNode = oneIndexed ? 1 : 0; //index of source node\n    while (nextOpenBracket !== -1) {\n      const nextCloseBracket = input.indexOf(\"]\", nextOpenBracket);\n      if (nextCloseBracket === -1) throw new Error(\"Missing a ']'\");\n  \n      const src = srcNode.toString();\n      nodeSet.add(src);\n  \n      try {\n        const arr = parseArray(input.slice(nextOpenBracket + 1, nextCloseBracket));\n        for (let trg of arr) {\n          nodeSet.add(trg); // add target to nodeSet too\n        if (src !== trg) {\n          //TODO: should we handle self-links?\n          links.push({ source: src, target: trg });\n        }\n        }\n      } catch (ex) {\n        throw ex;\n      }\n  \n      startInd = nextCloseBracket;\n      nextOpenBracket = input.indexOf(\"[\", startInd);\n      srcNode++;\n  }\n  return { nodeSet: nodeSet, links: links };\n}\n\nfunction parseArray(s: string): any[] {\n    s = s.trim();\n  \n    const rtn: any[] = [];\n  \n    const sp = s.split(\",\");\n    for (let elem of sp) {\n      const toAdd = cleanseInput(elem);\n      if (toAdd.length > 0) {\n        rtn.push(toAdd);\n      }\n    }\n  \n    return rtn;\n}\n// adjacency matrix\n// n x n binary matrix where arr[i][j] means there is a connection between i and j\nexport function parseAdjacencyMatrix(config: { input: string }): any {\n  let { input } = config;\n  input = input.trim();\n  if (input.length < 2) throw new Error(\"Input too short\");\n  input = input.slice(1, input.length - 1);\n\n  // TODO: parse each row of the matrix and add a connection between row i and column j when 1 is encountered\n  const matrix: string | any[] = [];\n  const links = [];\n  const nodeSet = new Set<string>();\n\n  let startInd = 0;\n  let nextOpenBracket = input.indexOf(\"[\", startInd);\n  let srcNode = 0; // index of source node\n  while (nextOpenBracket !== -1) {\n    const nextCloseBracket = input.indexOf(\"]\", nextOpenBracket);\n    if (nextCloseBracket === -1) throw new Error(\"No matching close bracket\");\n\n    const src = srcNode.toString();\n    nodeSet.add(src);\n\n    startInd = nextCloseBracket;\n    nextOpenBracket = input.indexOf(\"[\", startInd);\n    srcNode++;\n  }\n\n  const n = matrix.length;\n  for (let i = 0; i < matrix.length; i++) {\n    const arr = matrix[i];\n    if (arr.length !== n) throw new Error(\"Adjacency matrix has incorrect column size(s)\");\n    for (let j = 0; j < n; j++) {\n      const colVal = arr[j];\n      const colValNum = parseInt(colVal);\n      if (colValNum === 1) {\n        links.push({ source: i.toString(), target: j.toString() });\n      }\n    }\n  }\n\n  return { nodeSet: nodeSet, links: links };\n}\n\nexport function parseGraphJSON(config: { input: string }) {\n  let { input } = config;\n  input = input.trim();\n  let jsonObj: any;\n  try {\n    jsonObj = parseJson(input); // parseJson library will automatically handle and throw error in syntax\n  } catch (error) {\n    throw new Error(error.message);\n  }\n  if (!jsonObj.nodes) {\n    throw new Error(\"JSON object is missing the `nodes` property\");\n  }\n  let nodes = jsonObj.nodes;\n\n  const nodeSet = new Set<string>();\n  const links = [];\n\n  for (let node of nodes) {\n    nodeSet.add(node.id);\n    if (node.children) {\n      let children = node.children;\n      for (let child of children) {\n        links.push({ source: node.id, target: child });\n      }\n    }\n  }\n\n  return { startNode: jsonObj.startNode, nodeSet: nodeSet, links: links };\n}\n\nexport function parseBinaryTreeJSON(config: { input: string }) {\n  let { input } = config;\n  input = input.trim();\n  let jsonObj: any;\n  try {\n    jsonObj = parseJson(input); // parseJson library will automatically handle and throw error in syntax\n  } catch (error) {\n    throw new Error(error.message);\n  }\n\n  if (!jsonObj.nodes) {\n    throw new Error(\"JSON object is missing the `nodes` property\");\n  }\n  let nodes = jsonObj.nodes;\n\n  const nodeSet = new Set<string>();\n  const links = [];\n\n  const idToNode: any = {};\n\n  for (let node of nodes) {\n    nodeSet.add(node.id);\n    const tNode = new TreeNode(node.id);\n    idToNode[node.id] = tNode;\n\n    if (node.left) {\n      links.push({ source: node.id, target: node.left });\n    }\n    if (node.right) {\n      links.push({ source: node.id, target: node.right });\n    }\n  }\n\n  // second traverse: construct links and mark isRightChild\n  for (let node of nodes) {\n    const tNode = idToNode[node.id];\n\n    if (node.left) {\n      tNode.children.push(idToNode[node.left]);\n    }\n    if (node.right) {\n      tNode.children.push(idToNode[node.right]);\n      idToNode[node.right].isRightChild = true;\n    }\n  }\n\n  return {\n    startNode: jsonObj.root,\n    tree: idToNode[jsonObj.root],\n    idToTreeNode: idToNode,\n    nodeSet: nodeSet,\n    links: links\n  };\n}\n\n// Binary tree/heap in array form (child is at 2n+1 and 2n+2)\n// differentiate between id and label\nexport function parseBinaryHeap(config: { input: string }) {\n  let { input } = config;\n  input = input.trim();\n  if (input.length < 2) {\n    throw new Error(\"Input too short\");\n  }\n  input = input.slice(1, input.length - 1);\n  input = input.trim();\n  if (input.length === 0) {\n    throw new Error(\"Input too short\");\n  }\n  const nodeSet = new Set<string>();\n  const nodeToLabel: any = {};\n  const links: Array<any> = [];\n  if (input.indexOf(\",\") === -1) {\n    nodeSet.add(input);\n    return { startNode: input, nodeSet: nodeSet, links: links };\n  }\n\n  let sp = input.split(\",\");\n  sp = sp.map((elem, ind) => {\n    let trimmed = cleanseInput(elem);\n    let key = ind + \" index\";\n    nodeToLabel[key] = trimmed;\n    nodeSet.add(key);\n    return key;\n  });\n  const idToNode: any = {};\n  let root: string | undefined;\n  for (let i = 0; i < sp.length; i++) {\n    const src = sp[i];\n    nodeSet.add(src);\n    if (!idToNode.hasOwnProperty(src)) {\n      const tNode = new TreeNode(src);\n      idToNode[src] = tNode;\n    }\n    if (i === 0) {\n      root = src;\n    }\n\n    let leftChildInd = i * 2 + 1;\n    let rightChildInd = i * 2 + 2;\n    if (leftChildInd < sp.length) {\n      const targetId = leftChildInd + \" index\";\n      // link child node\n      const tNode = new TreeNode(targetId);\n      idToNode[targetId] = tNode;\n      idToNode[src].children.push(tNode);\n\n      links.push({ source: src, target: targetId });\n    }\n    if (rightChildInd < sp.length) {\n      const targetId = rightChildInd + \" index\";\n      // link child node\n      const tNode = new TreeNode(targetId);\n      idToNode[targetId] = tNode;\n      idToNode[src].children.push(tNode);\n      tNode.isRightChild = true;\n\n      links.push({ source: src, target: targetId });\n    }\n  }\n  return {\n    startNode: root,\n    tree: idToNode[root as string],\n    idToTreeNode: idToNode,\n    nodeSet: nodeSet,\n    nodeToLabel: nodeToLabel,\n    links: links\n  };\n}\n\n// Leetcode's binary tree serialization\n// (modified bfs; see https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-)\n// differentiate between id and label\nexport function parseLeetcodeTree(config: { input: string }) {\n  let { input } = config;\n  input = input.trim();\n  if (input.length < 2) {\n    throw new Error(\"Input too short\");\n  }\n  input = input.slice(1, input.length - 1);\n  input = input.trim();\n  if (input.length === 0) {\n    throw new Error(\"Input too short\");\n  }\n\n  const nodeSet = new Set<string>();\n  const nodeToLabel: any = {};\n  const links: Array<any> = [];\n\n  if (input.indexOf(\",\") === -1) {\n    nodeSet.add(input);\n    return { startNode: input, nodeSet: nodeSet, links: links };\n  }\n\n  const idToNode: any = {};\n  let sp = input.split(\",\");\n  sp = sp.map((elem, ind) => {\n    let trimmed = cleanseInput(elem);\n    let key = ind + \" index\";\n    if (trimmed !== \"null\") {\n      nodeSet.add(key);\n      const tNode = new TreeNode(key);\n      idToNode[key] = tNode;\n      nodeToLabel[key] = trimmed;\n    }\n    return elem.trim();\n  });\n\n  let queue = []; // queue.shift() to dequeue\n  queue.push(\"0 index\");\n  let ind = 1;\n  while (queue.length > 0) {\n    let src = queue.shift();\n    if (ind >= sp.length) break;\n    let trg = sp[ind];\n    if (trg !== \"null\") {\n      // left child\n      // connect and add to queue\n      trg = ind + \" index\";\n\n      idToNode[src as string].children.push(idToNode[trg]);\n      links.push({ source: src, target: trg });\n      queue.push(trg);\n    }\n    ind++;\n    if (ind >= sp.length) break;\n    trg = sp[ind];\n    if (trg !== \"null\") {\n      // right child\n      trg = ind + \" index\";\n\n      idToNode[src as string].children.push(idToNode[trg]);\n      idToNode[trg].isRightChild = true;\n      links.push({ source: src, target: trg });\n      queue.push(trg);\n    }\n    ind++;\n  }\n\n  return {\n    startNode: \"0 index\",\n    tree: idToNode[\"0 index\"],\n    idToTreeNode: idToNode,\n    nodeSet: nodeSet,\n    nodeToLabel: nodeToLabel,\n    links: links\n  };\n}\n\nexport function parseNodes(input: string) {\n  const nodeSet = new Set<string>();\n  input = input.trim();\n  if (input.length < 2) {\n    throw new Error(\"Input too short\");\n  }\n  input = input.slice(1, input.length - 1);\n  input = input.trim();\n  if (input.length === 0) {\n    return nodeSet;\n  }\n  if (input.indexOf(\",\") === -1) {\n    nodeSet.add(cleanseInput(input));\n    return nodeSet;\n  }\n  const sp = input.split(\",\");\n  for (let s of sp) {\n    s = cleanseInput(s);\n    if (s.length) nodeSet.add(s);\n  }\n  return nodeSet;\n}\n","import React from \"react\";\nimport { Button, Tooltip } from \"@material-ui/core\";\nimport { withStyles } from \"@material-ui/core/styles\";\nimport { Help as HelpIcon } from \"@material-ui/icons\";\n\nexport const LabelWithTooltip = ({\n    tooltipText,\n    label,\n    inputRef\n}: {\n    tooltipText: string;\n    label: string;\n    inputRef: React.RefObject<HTMLInputElement>;\n}) => {\n    return (\n        <div\n            onClick={() => {\n                if (inputRef && inputRef.current) {\n                    inputRef.current.focus();\n                }\n            }}\n        >\n            {label}\n            <Tooltip\n                style={{ height: \"20px\", margin: \"0px 0px -4px 4px\" }}\n                title={tooltipText}\n                placement=\"right\"\n            >\n                <HelpIcon />\n            </Tooltip>\n        </div>\n    );\n};\n\nconst lightred = \"#e83838\";\nconst red = \"#e60e0e\";\nconst lightGrey = \"#eeeeee\";\n\nexport const ColorButton = withStyles(theme => ({\n    root: {\n        color: theme.palette.getContrastText(lightGrey),\n        backgroundColor: lightGrey,\n        \"&:hover\": {\n            backgroundColor: lightred\n        }\n    }\n}))(Button);\n\nexport const SelectedButton = withStyles(theme => ({\n    root: {\n        color: theme.palette.getContrastText(red),\n        backgroundColor: red,\n        \"&:hover\": {\n            backgroundColor: red\n        }\n    }\n}))(Button);","import React from \"react\";\nimport clsx from \"clsx\";\nimport \"./App.css\";\nimport Graph from \"./graph/Graph\";\nimport * as ParseUtils from \"./parser/parseUtils\";\nimport { InputType, getLabel } from \"./parser/inputTypes\";\nimport { LayoutType, getLayoutLabel } from \"./layout/layoutTypes\";\nimport {\n  FormControl,\n  MenuItem,\n  InputLabel,\n  Select,\n  AppBar,\n  Drawer,\n  Toolbar,\n  Divider,\n  IconButton,\n  Typography,\n  TextField,\n  FormControlLabel,\n  Checkbox,\n  Slider\n} from \"@material-ui/core\";\nimport { Autocomplete } from \"@material-ui/lab\";\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport { useStyles } from \"./styles/useStyles\";\nimport { Menu as MenuIcon, ChevronLeft as ChevronLeftIcon } from \"@material-ui/icons\";\nimport { LabelWithTooltip, ColorButton, SelectedButton } from \"./utils/helperComponents\";\nimport { TreeNode } from \"./layout/treeLayout\";\nimport SearchBar from \"material-ui-search-bar\";\n\nconst DEFAULT_INPUT_TYPE = InputType.AdjacencyList;\nconst DEFAULT_LAYOUT_TYPE = LayoutType.Tree;\nconst DEFAULT_GRAPH_INPUT = ``;\n\nexport type MyGraphNodeType = { id: string; label: string; x?: number; y?: number };\nexport type MyGraphLinkType = { source: string; target: string; label?: string };\nexport type MyDataType = {\n  nodes: Array<MyGraphNodeType>;\n  links: Array<MyGraphLinkType>;\n  startNode?: string;\n  directed?: boolean;\n  tree?: TreeNode;\n  idToTreeNode?: { [key: string]: TreeNode };\n};\n\nfunction App() {\n  const classes = useStyles();\n  // layout\n  const [drawerOpen, setDrawerOpen] = React.useState(true);\n\n  // input data\n  const [inputValue, setInputValue] = React.useState(DEFAULT_GRAPH_INPUT);\n  const [comboValue, setComboValue] = React.useState(DEFAULT_INPUT_TYPE);\n  const [directed, setDirected] = React.useState(true);\n  const [oneIndexed, setOneIndexed] = React.useState(false); // used for adjacency lists\n  const [reverseEdges, setReverseEdges] = React.useState(false); // used for edge pairs\n  const [customNodes, setCustomNodes] = React.useState(DEFAULT_GRAPH_INPUT);\n\n  const [allNodes, setAllNodes] = React.useState<Array<string>>([]);\n  const [startNode, setStartNode] = React.useState<string | null>(null);\n\n  // error handling\n  const [graphInputError, setGraphInputError] = React.useState(\"\");\n  const [customNodesInputError, setCustomNodesInputError] = React.useState(\"\");\n\n  // graph payload (with minimalist structure)\n  const [customNodeSet, setCustomNodeSet] = React.useState(new Set<string>());\n  const [data, setData] = React.useState<MyDataType>({\n    nodes: [],\n    links: []\n  });\n\n  // layout\n  const [selectedLayout, setSelectedLayout] = React.useState(DEFAULT_LAYOUT_TYPE);\n  const [searchInputValue, setSearchInputValue] = React.useState(\"\");\n  const [searchText, setSearchText] = React.useState(\"\");\n\n  const graphInputRef = React.useRef<any>();\n  const customNodesInputRef = React.useRef<any>();\n  const reverseRef = React.useRef(false);\n\n  const [verticalSlider, setVerticalSlider] = React.useState<number>(2);\n  const [horizontalSlider, setHorizontalSlider] = React.useState<number>(2);\n\n  // handle changes to graph input, input type, associated options (i.e. 1-indexed)\n  React.useEffect(() => {\n    if (!inputValue) return;\n\n    let parsedValue: any;\n    try {\n      parsedValue = ParseUtils.processInput(inputValue, comboValue, {\n        oneIndexed,\n        reverseEdges\n      });\n\n      if (parsedValue.nodeSet.size === 0) {\n        setGraphInputError(\"There are no valid nodes in the input.\");\n        return;\n      }\n    } catch (error) {\n      setGraphInputError(error.message);\n      return;\n    }\n\n    let reverseChanged = false;\n    if (reverseEdges !== reverseRef.current) {\n      reverseChanged = true;\n      reverseRef.current = reverseEdges;\n    }\n\n    const nodeToLabel = parsedValue.nodeToLabel ? parsedValue.nodeToLabel : {};\n\n    parsedValue.nodes = Array.from(parsedValue.nodeSet).map(nodeId => {\n      return {\n        id: nodeId as string,\n        label: nodeToLabel.hasOwnProperty(nodeId) ? nodeToLabel[nodeId as string] : nodeId\n      };\n    });\n    if (parsedValue.startNode) {\n      setStartNode(parsedValue.startNode);\n    } else {\n      if (!reverseChanged) {\n        setStartNode(null);\n      }\n    }\n\n    setGraphInputError(\"\");\n    setData(parsedValue);\n  }, [inputValue, comboValue, oneIndexed, reverseEdges]);\n\n  // handle changes to custom nodes input ()\n  React.useEffect(() => {\n    if (!customNodes) return;\n\n    let parsedValue: Set<string>;\n    try {\n      parsedValue = ParseUtils.parseNodes(customNodes);\n    } catch (ex) {\n      setCustomNodesInputError(ex.message);\n      return;\n    }\n    setCustomNodesInputError(\"\");\n    setCustomNodeSet(parsedValue);\n  }, [customNodes]);\n\n  React.useEffect(() => {\n    let allNodesSet = new Set();\n    for (let n of data.nodes) {\n      allNodesSet.add(n.id);\n    }\n    for (let nodeId of Array.from(customNodeSet)) {\n      allNodesSet.add(nodeId);\n    }\n    let tempAllNodes = Array.from(allNodesSet) as Array<string>;\n    tempAllNodes.sort();\n\n    setAllNodes(tempAllNodes);\n  }, [customNodeSet, data]);\n\n  return (\n    <div className={classes.root}>\n      <CssBaseline />\n      <AppBar\n        position=\"fixed\"\n        className={clsx(classes.appBar, {\n          [classes.appBarShift]: drawerOpen\n        })}\n      >\n        <Toolbar>\n          <IconButton\n            color=\"inherit\"\n            aria-label=\"open drawer\"\n            onClick={() => {\n              setDrawerOpen(true);\n            }}\n            edge=\"start\"\n            className={clsx(classes.menuButton, drawerOpen && classes.hide)}\n          >\n            <MenuIcon />\n          </IconButton>\n\n          <Typography variant=\"h6\" noWrap>\n            Choose Layout Type:\n          </Typography>\n\n          {/* Classify buttons into Selected button(Red color) and Normal buttons(Light Grey color) */}\n          {Object.keys(LayoutType)\n            .filter(k => typeof LayoutType[k as any] !== \"number\")\n            .map(key => {\n              let currLayoutType = parseInt(key);\n              return currLayoutType === selectedLayout ? (\n                <SelectedButton\n                  key={key}\n                  className={classes.layoutButton}\n                  variant=\"contained\"\n                  onClick={() => {\n                    setSelectedLayout(currLayoutType);\n                  }}\n                >\n                  {getLayoutLabel(parseInt(key))}\n                </SelectedButton>\n              ) : (\n                <ColorButton\n                  key={key}\n                  className={classes.layoutButton}\n                  variant=\"contained\"\n                  onClick={() => {\n                    setSelectedLayout(currLayoutType);\n                  }}\n                >\n                  {getLayoutLabel(parseInt(key))}\n                </ColorButton>\n              );\n            })}\n\n          <div className={classes.searchBar}>\n            <SearchBar\n              value={searchInputValue}\n              onChange={newValue => setSearchInputValue(newValue)}\n              onRequestSearch={() => setSearchText(searchInputValue)}\n              onCancelSearch={() => setSearchText(\"\")}\n              placeholder={\"Search Nodes\"}\n              style={{\n                width: 200,\n                height: 36\n              }}\n            />\n          </div>\n        </Toolbar>\n      </AppBar>\n\n      <Drawer\n        className={classes.drawer}\n        variant=\"persistent\"\n        anchor=\"left\"\n        open={drawerOpen}\n        classes={{\n          paper: classes.drawerPaper\n        }}\n      >\n        <div className={classes.drawerHeader}>\n          <Typography className={classes.drawerHeaderText} variant=\"h6\" noWrap>\n            Graph Input\n          </Typography>\n          <IconButton\n            onClick={() => {\n              setDrawerOpen(false);\n            }}\n          >\n            <ChevronLeftIcon />\n          </IconButton>\n        </div>\n        <div>\n          <Divider />\n          <FormControl className={classes.formControl}>\n            <TextField\n              InputLabelProps={{ style: { pointerEvents: \"auto\" } }}\n              label={\n                <LabelWithTooltip\n                  label={\"Graph Input\"}\n                  tooltipText={\"Enter the text representation of the graph.\"}\n                  inputRef={graphInputRef}\n                />\n              }\n              inputRef={graphInputRef}\n              placeholder=\"Please enter graph input.\"\n              multiline\n              rows={3}\n              rowsMax={10}\n              variant=\"outlined\"\n              value={inputValue}\n              onChange={event => {\n                setInputValue(event.target.value);\n              }}\n              error={graphInputError.length > 0}\n              helperText={graphInputError}\n            />\n          </FormControl>\n          <FormControl className={classes.formControl}>\n            <InputLabel id=\"graph-input-type-label\">Input Type</InputLabel>\n            <Select\n              labelId=\"graph-input-type-label\"\n              id=\"graph-input-type\"\n              value={comboValue}\n              className={classes.selectEmpty}\n              variant=\"outlined\"\n              onChange={e => {\n                setComboValue(parseInt(e.target.value as string));\n              }}\n            >\n              {Object.keys(InputType)\n                .filter(k => typeof InputType[k as any] !== \"number\")\n                .sort((a, b) => getLabel(parseInt(a)).localeCompare(getLabel(parseInt(b))))\n                .map(key => (\n                  <MenuItem key={key} value={key}>\n                    {getLabel(parseInt(key))}\n                  </MenuItem>\n                ))}\n            </Select>\n          </FormControl>\n          {comboValue === InputType.AdjacencyList && (\n            <FormControlLabel\n              className={classes.formControlLabel}\n              control={\n                <Checkbox\n                  checked={oneIndexed}\n                  onChange={e => setOneIndexed(!oneIndexed)}\n                  name=\"oneIndexedValue\"\n                  color=\"primary\"\n                />\n              }\n              label=\"1-indexed\"\n            />\n          )}\n          {comboValue === InputType.EdgePairs && (\n            <FormControlLabel\n              className={classes.formControlLabel}\n              control={\n                <Checkbox\n                  checked={reverseEdges}\n                  onChange={e => setReverseEdges(!reverseEdges)}\n                  name=\"reverseValue\"\n                  color=\"primary\"\n                />\n              }\n              label=\"Reverse\"\n            />\n          )}\n          <FormControlLabel\n            className={classes.formControlLabel}\n            control={\n              <Checkbox\n                checked={directed}\n                onChange={e => setDirected(!directed)}\n                name=\"directedValue\"\n                color=\"primary\"\n              />\n            }\n            label=\"Directed\"\n          />\n          <FormControl className={classes.formControl}>\n            <Autocomplete\n              options={allNodes}\n              value={startNode && startNode.length > 0 ? startNode : null}\n              onChange={(event: React.ChangeEvent<{}>, newValue: string | null) => {\n                if (newValue) setStartNode(newValue);\n              }}\n              renderInput={(params: any) => (\n                <TextField {...params} label=\"Start Node\" margin=\"normal\" variant=\"outlined\" />\n              )}\n            />\n          </FormControl>\n          <FormControl className={classes.formControl}>\n            <TextField\n              InputLabelProps={{ style: { pointerEvents: \"auto\" } }}\n              label={\n                <LabelWithTooltip\n                  label={\"Custom Node List\"}\n                  tooltipText={\n                    \"(Optional) Specify if the set of nodes is described in a separate list from the edges.\"\n                  }\n                  inputRef={customNodesInputRef}\n                />\n              }\n              inputRef={customNodesInputRef}\n              placeholder=\"Enter custom node set here.\"\n              multiline\n              rows={3}\n              rowsMax={10}\n              variant=\"outlined\"\n              value={customNodes}\n              onChange={event => {\n                setCustomNodes(event.target.value);\n              }}\n              error={customNodesInputError.length > 0}\n              helperText={customNodesInputError}\n            />\n          </FormControl>\n        </div>\n      </Drawer>\n      <main\n        className={clsx(classes.mainContent, {\n          [classes.contentShift]: drawerOpen\n        })}\n      >\n        <div className={classes.drawerHeader} />\n        <Graph\n          id=\"graph-id\" // id is mandatory, if no id is defined rd3g will throw an error\n          inputType={comboValue}\n          directed={directed}\n          customNodes={customNodeSet}\n          startNode={startNode}\n          data={data}\n          selectedLayout={selectedLayout}\n          drawerOpen={drawerOpen}\n          searchText={searchText}\n          horizontalSpacing={horizontalSlider}\n          verticalSpacing={verticalSlider}\n        />\n        <div className={classes.sliders}>\n          {selectedLayout !== LayoutType.ForceLayout && selectedLayout !== LayoutType.Random && (\n            <>\n              <Typography id=\"continuous-slider\" gutterBottom>\n                Horizontal Spacing\n              </Typography>\n              <Slider\n                value={horizontalSlider}\n                onChange={(event, newValue) => {\n                  setHorizontalSlider(newValue as number);\n                }}\n                aria-labelledby=\"discrete-slider\"\n                step={1}\n                marks\n                min={0}\n                max={4}\n              />\n            </>\n          )}\n          {selectedLayout !== LayoutType.ForceLayout &&\n            selectedLayout !== LayoutType.Random &&\n            selectedLayout !== LayoutType.Arc && (\n              <>\n                <Typography id=\"continuous-slider\" gutterBottom>\n                  Vertical Spacing\n                </Typography>\n                <Slider\n                  value={verticalSlider}\n                  onChange={(event, newValue) => {\n                    setVerticalSlider(newValue as number);\n                  }}\n                  aria-labelledby=\"discrete-slider\"\n                  step={1}\n                  marks\n                  min={0}\n                  max={4}\n                />\n              </>\n            )}\n        </div>\n      </main>\n    </div >\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}